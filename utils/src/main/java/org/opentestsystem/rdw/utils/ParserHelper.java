package org.opentestsystem.rdw.utils;

import org.springframework.util.StringUtils;

import javax.validation.constraints.NotNull;
import java.time.LocalDate;
import java.time.Year;
import java.time.format.DateTimeParseException;
import java.util.function.Function;

/**
 * Helper methods for parsing and validating data elements
 */
public class ParserHelper {

    private final DataElementErrorCollector elementErrorCollector;

    /**
     * General construction that collects errors in to a {@link DataElementErrorCollector}
     *
     * @param elementErrorCollector error collector to use for any errors
     */
    public ParserHelper(@NotNull final DataElementErrorCollector elementErrorCollector) {
        this.elementErrorCollector = elementErrorCollector;
    }

    public ParserHelper() {
        this.elementErrorCollector = new DataElementErrorCollector();
    }

    public DataElementErrorCollector getElementErrorCollector(){
        return elementErrorCollector;
    }

    /**
     * Convenience method to add an error to the contained error collector.
     *
     * @param dataElementError error to add
     * @return this ParserHelper
     */
    public ParserHelper addError(final DataElementError dataElementError) {
        elementErrorCollector.add(dataElementError);
        return this;
    }

    /**
     * Basic typed validation.  Any exception is converted into an error and added to the error collector.
     *
     * @param name       name of field, used only for error message
     * @param rawValue   raw field value
     * @param validateFx validation function
     * @param <T>        input data type
     * @param <R>        result data type
     * @return validated value of type T, may be null
     */
    public <T, R> R validate(final String name, final T rawValue, final Function<T, R> validateFx) {
        try {
            return validateFx.apply(rawValue);
        } catch (final Exception ex) {
            elementErrorCollector.add(new DataElementError(name, rawValue == null ? null : rawValue.toString(), ex.getMessage()));
            return null;
        }
    }

    /**
     * String value validation.
     * It is a shortcut for {@link ParserHelper#checkNotBlank} and a string max length verification.
     * It effectively does trim-to-null on any blank or empty value.
     *
     * @param name            name of field, used only for error message
     * @param rawValue        raw field value
     * @param maxLength       max length of the string for the successful validation
     * @param enforceNotEmpty to allow for null or empty value
     * @return validated value
     */
    public String validate(final String name, final String rawValue, final int maxLength, final boolean enforceNotEmpty) {
        if (!StringUtils.hasText(rawValue)) {
            if (enforceNotEmpty) {
                elementErrorCollector.add(new DataElementError(name, rawValue, "value may not be blank"));
            }
            return null;
        }

        final String validatedString = rawValue.trim();
        if (validatedString.length() > maxLength) {
            elementErrorCollector.add(new DataElementError(name, rawValue, "string is too long, max length is " + maxLength));
        }
        return validatedString;
    }

    /*
     * Helper functions for string parsing to be passed into {@link ParserHelper#validate(String, Object, Function)}
     * as the validation {@link Function}
     */

    /**
     * Converts the given string value into a {@link Boolean}
     * <p>
     * Boolean@throws IllegalArgumentException if value can't be interpreted as a boolean
     */
    public static final Function<String, Boolean> toBoolean = value -> {
        if ("Yes".equalsIgnoreCase(value) || "y".equalsIgnoreCase(value)) return true;
        if ("TRUE".equalsIgnoreCase(value) || "T".equalsIgnoreCase(value)) return true;
        if ("1".equals(value)) return true;

        if ("No".equalsIgnoreCase(value) || "n".equalsIgnoreCase(value)) return false;
        if ("FALSE".equalsIgnoreCase(value) || "F".equalsIgnoreCase(value)) return false;
        if ("0".equals(value)) return false;

        throw new IllegalArgumentException("invalid value [" + value + "]");
    };

    public static final Function<String, Boolean> toBooleanOrNull = value ->
            StringUtils.hasText(value) ? toBoolean.apply(value.trim()) : null;

    /**
     * Convert a given {@link Long} value into a valid year
     */
    public static final Function<Long, Integer> toYear = value -> {
        if (value == null) throw new IllegalArgumentException("invalid year");

        if (value >= Year.MIN_VALUE && value <= Year.MAX_VALUE) return value.intValue();

        throw new IllegalArgumentException("invalid year");
    };

    public static final Function<String, String> checkNotBlank = value -> {
        Precondition.checkNotBlank(value);
        return value.trim();
    };

    public static final Function<String, Long> toLong = value -> {
        Precondition.checkNotBlank(value);
        return Long.parseLong(value);
    };

    public static final Function<String, Double> toDouble = value -> {
        Precondition.checkNotBlank(value);
        return Double.parseDouble(value);
    };

    public static final Function<String, Integer> toInteger = value -> {
        Precondition.checkNotBlank(value);
        return Integer.parseInt(value);
    };

    public static final Function<String, LocalDate> toLocalDate = value -> {
        Precondition.checkNotBlank(value);
        try {
            return LocalDate.parse(value.trim());
        } catch (final DateTimeParseException e) {
            // the message from parse is a bit cryptic and includes single quotes, so provide our own
            throw new IllegalArgumentException("invalid date [" + value + "], use format YYYY-MM-DD");
        }
    };

    public static final Function<String, Double> toDoubleOrNull = value ->
            StringUtils.hasText(value) ? Double.parseDouble(value.trim()) : null;

    public static final Function<String, Integer> toIntegerOrNull = value ->
            StringUtils.hasText(value) ? Integer.parseInt(value.trim()) : null;

    public static final Function<String, LocalDate> toLocalDateOrNull = value ->
            StringUtils.hasText(value) ? toLocalDate.apply(value.trim()) : null;

    public static Function<String, String> toGrade = value -> {
        Precondition.checkNotBlank(value);
        return value.length() == 1 ? "0" + value : value; //Grade codes need to be two characters. e.g. KG, PK, 01, 02, 11, 12..
    };
}
