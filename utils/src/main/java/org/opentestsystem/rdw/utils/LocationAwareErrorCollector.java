package org.opentestsystem.rdw.utils;

import com.google.common.base.Joiner;
import com.google.common.collect.Lists;
import com.google.common.collect.Ordering;
import com.google.common.collect.Queues;
import com.google.gson.GsonBuilder;

import java.util.Deque;
import java.util.List;

import static com.google.common.collect.Lists.newArrayList;

/**
 * This class is responsible for maintaining the current state of a
 * validation process.  It tracks the current "location" as well as stores
 * and collates any validation failure messages.
 * @see DataElementErrorCollector for a non-location-aware collector implementation
 */
public class LocationAwareErrorCollector {
    private static final Joiner LocationJoiner = Joiner.on(":");
    private static final Ordering<DataElementError> FailureOrdering = Ordering.natural()
            .onResultOf(DataElementError::getElementName);
    static final int MaxMessageCount = 100;

    private final Deque<String> location;
    private final List<DataElementError> messages;

    public LocationAwareErrorCollector() {
        this.location = Queues.newArrayDeque();
        this.messages = Lists.newArrayList();
    }

    /**
     * Push an additional location name onto the location stack.
     * (Example: "SubScoring")
     *
     * @param name The location name
     */
    public void push(final String name) {
        this.location.push(name);
    }

    /**
     * Push an additional location name with an id onto the location stack.
     * (Example: "AssessmentType(ica)")
     *
     * @param name  The location name
     * @param id    The location id
     */
    public void push(final String name, final String id) {
        this.location.push(name + "(" + id + ")");
    }

    /**
     * Remove the top (most recent) location from the location stack.
     */
    public void pop() {
        if (location.isEmpty()) return;

        location.pop();
    }

    /**
     * Add a failure message with the current location.
     *
     * @param message The failure detail message
     */
    public void failure(final String message) {
        failure(message, null);
    }

    /**
     * Add a failure message and value with the current location.
     *
     * @param message   The failure detail message
     * @param value     The failing value
     */
    public void failure(final String message, final String value) {
        final List<String> orderedLocation = Lists.reverse(Lists.newArrayList(location));
        messages.add(new DataElementError(
                LocationJoiner.join(orderedLocation),
                value,
                message));
    }

    /**
     * @return The current failure messages
     */
    public List<DataElementError> getMessages() {
        return FailureOrdering.sortedCopy(messages);
    }

    /**
     * @return A JSON representation of the current failure messages and locations, limited to 100 failure messages
     */
    public String toJson() {
        List<DataElementError> messages = getMessages();

        //Truncate to MaxMessageCount failure messages.
        if (messages.size() > MaxMessageCount) {
            final List<DataElementError> truncatedFailures = Lists.newArrayList(messages.subList(0, MaxMessageCount));
            truncatedFailures.add(new DataElementError(
                    "System",
                    null,
                    "With " + (messages.size() - MaxMessageCount) + " additional failures."
            ));
            messages = truncatedFailures;
        }

        return new GsonBuilder()
                .excludeFieldsWithoutExposeAnnotation()
                .create()
                .toJson(messages);
    }

    /**
     * @return True if there are no validation failure messages
     */
    public boolean isValid() {
        return messages.isEmpty();
    }
}
