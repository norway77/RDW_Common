package org.opentestsystem.rdw.script;

import org.apache.tools.ant.util.FileUtils;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.ExpectedException;
import org.junit.runner.RunWith;
import org.mockito.Mock;
import org.mockito.junit.MockitoJUnitRunner;

import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.Reader;
import java.security.AccessControlException;
import java.util.Collections;
import java.util.Map;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import org.opentestsystem.rdw.script.security.DefaultSandboxPermissions;
import org.opentestsystem.rdw.script.security.SandboxSecurityManager;

import static org.assertj.core.api.Assertions.assertThat;
import static org.hamcrest.CoreMatchers.containsString;
import static org.hamcrest.core.IsInstanceOf.instanceOf;
import static org.mockito.Mockito.when;


@RunWith(MockitoJUnitRunner.class)
public class SandboxTest {
    private static final String SAMPLE_XML = "<book><chapter>blah</chapter><chapter>blah blah</chapter></book>";
    private static final ExecutorService pool = Executors.newFixedThreadPool(1);

    private static SandboxSecurityManager sandboxSecurityManager;
    private ScriptCompiler compiler;
    private final ScriptPipelineConfiguration configuration = new ScriptPipelineConfiguration();

    @Mock
    private ScriptSource scriptSource;

    @Rule
    public ExpectedException exception = ExpectedException.none();

    @BeforeClass
    public static void changeSecurityPolicy() {
        sandboxSecurityManager = new SandboxSecurityManager(new DefaultSandboxPermissions());
        sandboxSecurityManager.disable();
        System.setSecurityManager(sandboxSecurityManager);
    }

    @Before
    public void setup() throws Exception {
        when(scriptSource.loadScriptBaseClass()).thenReturn(
                loadFromResourceFile("/scripts/DSLScriptBase.groovy"));

        compiler = new ScriptCompiler(configuration.groovyClassLoader(scriptSource));
    }

    @Test
    public void itShouldRunSafeCodeInSandbox() throws Exception {

        Callable<String> callable = () -> {
            sandboxSecurityManager.enable();

            return "hello";
        };

        assertThat(pool.submit(callable).get()).isEqualTo("hello");
    }

    @Test
    public void itShouldErrorOnDangerousCodeInSandbox() throws Exception {
        exception.expect(ExecutionException.class);
        exception.expectCause(instanceOf(AccessControlException.class));

        final Callable<String> callable = () -> {
            sandboxSecurityManager.enable();

            try {
                FileOutputStream out = new FileOutputStream("/tmp/hello");
                out.write("nasty virus".getBytes());
                out.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
            return "hello";
        };

        pool.submit(callable).get();
    }

    @Test
    public void itShouldRunSafeScriptInSandbox() throws Exception {
        final String scriptCode =
                "enable 'xml'\n"  +
                "transform '//chapter' by {\n"  +
                "    it.text = it.text + '!'\n"  +
                "}\n"  +
                "outputXml";

        final Object results = runInSandbox(scriptCode, Collections.emptyMap());
        assertThat(results).isNotNull();
    }

    @Test
    public void itShouldErrorOnDangerousScriptInSandbox() throws Exception {
        exception.expect(ScriptRuntimeException.class);
        exception.expectMessage(containsString("line 1"));
        exception.expectMessage(containsString("access denied"));
        exception.expectCause(instanceOf(AccessControlException.class));

        final String scriptCode =
                "new File('/tmp/hello').withWriter('utf-8') { writer ->\n" +
                        "    writer.writeLine 'virus line 1'\n" +
                        "    writer.writeLine 'hmm maybe overrun a buffer?'\n" +
                        "    writer.writeLine 'demand ransom!'\n" +
                        "}";

        runInSandbox(scriptCode, Collections.emptyMap());
    }

    @Test
    public void itShouldErrorOnSetSecurityManager() throws Exception {
        exception.expect(ScriptRuntimeException.class);
        exception.expectCause(instanceOf(AccessControlException.class));

        final String scriptCode =
                "System.setSecurityManager(null)\n"  +
                "return 'Hello'";

        runInSandbox(scriptCode, Collections.singletonMap("securityManager", sandboxSecurityManager));
    }

    @Test
    public void itShouldErrorOnDisableSandboxFromSystem() throws Exception {
        exception.expect(ScriptRuntimeException.class);
        exception.expectCause(instanceOf(AccessControlException.class));

        final String scriptCode =
                "System.getSecurityManager().disable()\n"  +
                "return 'Hello'";

        runInSandbox(scriptCode, Collections.emptyMap());
    }

    @Test
    public void itShouldErrorOnStartThread() throws Exception {
        exception.expect(ScriptRuntimeException.class);
        exception.expectCause(instanceOf(SecurityException.class));

        final String scriptCode =
                        "new Thread() {\n" +
                        "  public void run() {\n" +
                                "FileWriter fw = new FileWriter('/tmp/hello')\n" +
                                "fw.write('urfed')\n" +
                                "fw.flush()\n" +
                                "fw.close()" +
                        "  }\n" +
                        "}.start()";

        runInSandbox(scriptCode, Collections.emptyMap());
    }


    @Test
    public void itShouldErrorOnDisableSandboxFromProperty() throws Exception {
        exception.expect(ScriptRuntimeException.class);
        exception.expectCause(instanceOf(AccessControlException.class));

        final String scriptCode =
                "securityManager.disable()\n"  +
                "return 'Hello'";

        runInSandbox(scriptCode, Collections.singletonMap("securityManager", sandboxSecurityManager));
    }

    private Object runInSandbox(final String scriptCode, Map<String,Object> properties) throws Exception {
        final PipelineScript script = compileScript(scriptCode)
                .bindProperties(properties)
                .bindInput(SAMPLE_XML.getBytes());

        Callable<Object> callable = () -> {
            sandboxSecurityManager.enable();
            return script.execute();
        };

        Future<Object> future = pool.submit(callable);
        try {
           return future.get();
        } catch (ExecutionException e) {
            throw (Exception)(e.getCause());
        }
    }

    private PipelineScript compileScript(final String scriptCode) throws Exception {
        final Class<? extends PipelineScript> scriptClass = compiler.compile(scriptCode);
        return scriptClass.newInstance();
    }

    private String loadFromResourceFile(final String name) throws Exception {
        final Reader scriptReader = new InputStreamReader(this.getClass().getResourceAsStream(name));
        return FileUtils.readFully(scriptReader);
    }
}