package org.opentestsystem.rdw.script;

import org.apache.commons.lang3.RandomUtils;
import org.apache.commons.lang3.StringUtils;
import org.hamcrest.BaseMatcher;
import org.hamcrest.Description;
import org.hamcrest.Matcher;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.Mock;
import org.mockito.junit.MockitoJUnitRunner;
import org.w3c.dom.Document;
import org.w3c.dom.Node;
import org.xml.sax.InputSource;
import org.xmlunit.builder.Input;
import org.xmlunit.xpath.JAXPXPathEngine;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.transform.Source;
import javax.xml.xpath.XPath;
import javax.xml.xpath.XPathConstants;
import javax.xml.xpath.XPathExpression;
import javax.xml.xpath.XPathFactory;
import java.io.ByteArrayInputStream;
import java.util.ArrayList;
import java.util.List;
import java.util.NoSuchElementException;
import java.util.stream.Collectors;
import java.util.stream.StreamSupport;
import org.opentestsystem.rdw.script.impl.DefaultConfigurationCompiler;
import org.opentestsystem.rdw.script.impl.EmptyPropertyResolver;
import org.opentestsystem.rdw.script.security.DefaultSandboxPermissions;
import org.opentestsystem.rdw.script.security.SandboxSecurityManager;

import static java.util.Collections.emptyMap;
import static java.util.Collections.singletonList;
import static java.util.Collections.singletonMap;
import static org.assertj.core.api.Assertions.assertThat;
import static org.hamcrest.CoreMatchers.equalTo;
import static org.hamcrest.CoreMatchers.not;
import static org.junit.Assert.assertThat;
import static org.mockito.Mockito.when;
import static org.opentestsystem.rdw.script.util.TestUtils.loadFromResourceFile;
import static org.opentestsystem.rdw.script.util.TestUtils.loadScriptFromFile;
import static org.opentestsystem.rdw.script.util.TestUtils.loadStringFromResourceFile;
import static org.xmlunit.matchers.EvaluateXPathMatcher.hasXPath;

@RunWith(MockitoJUnitRunner.class)
public class XmlPipelineTest {
    private static final String PIPELINE_NAME = "My Test Pipeline";
    private static final String PIPELINE_VERSION = "1.0";

    private PipelineFactory pipelineFactory;
    private byte [] originalXml;
    private VersionedResource nodeDefinition;
    private ScriptPipelineConfiguration config = new ScriptPipelineConfiguration();

    private static SandboxSecurityManager sandboxSecurityManager;

    @Mock
    private ScriptSource scriptSource;

    @BeforeClass
    public static void setupSecurityManager() {
        sandboxSecurityManager = new SandboxSecurityManager(new DefaultSandboxPermissions());
    }

    @Before
    public  void setup() throws Exception {
        nodeDefinition = new VersionedResource("test", "1.0", ResourceType.USER_NODE);

        PipelineDefinition pipelineDefinition = PipelineDefinition.builder()
                .name(PIPELINE_NAME)
                .version(PIPELINE_VERSION)
                .rollbackVersion("N/A")
                .nodeDefinitions(singletonList(nodeDefinition))
                .build();

        when(scriptSource.loadPipelineDefinition(PIPELINE_NAME, PIPELINE_VERSION))
                .thenReturn(pipelineDefinition);

        when(scriptSource.loadScriptBaseClass()).thenReturn(
                loadStringFromResourceFile("/scripts/DSLScriptBase.groovy"));

        ScriptCompiler scriptCompiler = new ScriptCompiler(config.groovyClassLoader(scriptSource));
        ConfigurationCompiler configurationCompiler = new DefaultConfigurationCompiler();
        PropertyResolver propertyResolver = new EmptyPropertyResolver();

        pipelineFactory = config.pipelineFactory(
                scriptSource,
                scriptCompiler,
                configurationCompiler,
                propertyResolver,
                sandboxSecurityManager);

        originalXml = loadFromResourceFile("/sample_xml/TDSReport.iab.2018_AIR_format.xml");
    }

    @Test
    public void itShouldTransformByScriptCommands() throws Exception {
        // Transform sample TRT file using the Groovy script commands with XML helper methods.
        // Test the results using equivalent tests to those in the Exam Processor module for testing
        // XSL transformation
        when(scriptSource.loadScript(nodeDefinition)).thenReturn(
                loadScriptFromFile("/scripts/exam_script.groovy", emptyMap()));

        Pipeline pipeline = pipelineFactory.getPipeline(PIPELINE_NAME, PIPELINE_VERSION);
        PipelineResults results = pipeline.run(originalXml);
        assertThat(results.isModified()).isTrue();

        verifyTransformedXml(results.asByteArray());
    }

    @Test(expected = ScriptRuntimeException.class)
    public void itShouldErrorOnDangerousScript() throws Exception {
        // Transform sample TRT file using the Groovy script commands with XML helper methods.
        // Test the results using equivalent tests to those in the Exam Processor module for testing
        // XSL transformation
        when(scriptSource.loadScript(nodeDefinition)).thenReturn(
                loadScriptFromFile("/scripts/exam_script_danger.groovy", emptyMap()));

        Pipeline pipeline = pipelineFactory.getPipeline(PIPELINE_NAME, PIPELINE_VERSION);
        pipeline.run(originalXml);
    }

    @Test
    public void itShouldTransformByXslScript() throws Exception {
        // Transform the same TRT file as above, but instead use a script that applies an XSL transformation
        // instead of Groovy commands for the transformation. Use the same tests to verify this transformation.
        String xsl = loadStringFromResourceFile("/xsl/exam.xsl");

        when(scriptSource.loadScript(nodeDefinition)).thenReturn(
                loadScriptFromFile("/scripts/exam_script_xsl.groovy", singletonMap("xslAllRules", xsl)));

        Pipeline pipeline = pipelineFactory.getPipeline(PIPELINE_NAME, PIPELINE_VERSION);
        PipelineResults results = pipeline.run(originalXml);
        assertThat(results.isModified()).isTrue();

        verifyTransformedXml(results.asByteArray());
    }

    @Test
    public void itShouldTransformByHybridScript() throws Exception {
        // Transform the same TRT file as above, but instead use a script that applies an XSL transformation
        // instead of Groovy commands for the transformation. Use the same tests to verify this transformation.
        String xsl = loadStringFromResourceFile("/xsl/exam_items_only.xsl");

        when(scriptSource.loadScript(nodeDefinition)).thenReturn(
                loadScriptFromFile("/scripts/exam_script_hybrid.groovy", singletonMap("xslItemRulesOnly", xsl)));

        Pipeline pipeline = pipelineFactory.getPipeline(PIPELINE_NAME, PIPELINE_VERSION);
        PipelineResults results = pipeline.run(originalXml);
        assertThat(results.isModified()).isTrue();

        verifyTransformedXml(results.asByteArray());
    }

    @Test
    public void itShouldFilterOutElements() {
        // Test ability to filter out elements with a boolean rule. All elements matching the XPath expression
        // and also matching this rule will be removed.
        final String scriptCode =
                "enable 'xml'\n"  +
                "delete '//Item' when { item ->\n"  +
                "    item.key == '37115' || item.key == '92135'\n"  +
                        "}\n"  +
                "outputXml";

        when(scriptSource.loadScript(nodeDefinition)).thenReturn(
                new ScriptInfo(scriptCode, emptyMap()));

        assertThat(originalXml, hasXPath("//Item[@key='37115']", not(isBlankString())));
        assertThat(originalXml, hasXPath("//Item[@key='92135']", not(isBlankString())));

        Pipeline pipeline = pipelineFactory.getPipeline(PIPELINE_NAME, PIPELINE_VERSION);

        byte [] newXml = pipeline.run(originalXml).asByteArray();

        assertThat(newXml, hasXPath("//Item[@key='37115']", isBlankString()));
        assertThat(newXml, hasXPath("//Item[@key='92135']", isBlankString()));
    }

    @Test
    public void itShouldFilterInElements() {
        // Test filter in with a boolean rule. All elements matching the XPath expression, but not matching the rule
        // will be removed.
        String scriptCode =
                "enable 'xml'\n"  +
                "delete '//Item' unless { item ->\n"  +
                        "    item.key == '37115'\n"  +
                        "}\n"  +
                "outputXml";

        when(scriptSource.loadScript(nodeDefinition)).thenReturn(
                new ScriptInfo(scriptCode, emptyMap()));

        assertThat(originalXml, hasXPath("//Item[@key='37115']", not(isBlankString())));

        Pipeline pipeline = pipelineFactory.getPipeline(PIPELINE_NAME, PIPELINE_VERSION);
        byte [] newXml = pipeline.run(originalXml).asByteArray();

        assertThat(newXml, hasXPath("//Item[not(@key='37115')]", isBlankString()));
    }

    @Test
    public void isShouldReportNoModifications() {
        final byte [] input = RandomUtils.nextBytes(1000);

        final String scriptCode =  "return input.clone()";

        when(scriptSource.loadScript(nodeDefinition)).thenReturn(
                new ScriptInfo(scriptCode, emptyMap()));

        final Pipeline pipeline = pipelineFactory.getPipeline(PIPELINE_NAME, PIPELINE_VERSION);
        final PipelineResults results = pipeline.run(input);
        assertThat(results.isModified()).isFalse();
    }

    // Used by the various transform tests
    private void verifyTransformedXml(byte [] xml) throws Exception {

        //
        // Item Bank Key transformation 10200 --> 200
        //
        assertThat(xml, hasXPath("//Item/@bankKey", equalTo("200")));
        assertThat(xml, not(hasXPath("//Item/@bankKey", equalTo("10200"))));

        //
        // Several response transformations based on type:
        //

        // MC
        assertThat(xml, hasXPath("//Response[@junit='mc']/text()", equalTo("A")));

        // MS
        assertThat(xml, hasXPath("//Response[@junit='ms']/text()", equalTo("A,C,D")));


        DocumentBuilder db = DocumentBuilderFactory.newInstance().newDocumentBuilder();
        InputSource is = new InputSource(new ByteArrayInputStream(xml));
        Document doc = db.parse(is);


        //EBSR
        final String ebsrXml = getEmbeddedXml(doc, "//Response[@junit='ebsr']");
        assertThat(ebsrXml, hasXPath("count(/itemResponse/response)", equalTo("2")));
        assertThat(ebsrXml, hasXPath("count(/itemResponse/response[@id='EBSR1']/value)", equalTo("1")));
        assertThat(ebsrXml, hasXPath("/itemResponse/response[@id='EBSR1']/value/text()", equalTo("B")));
        assertThat(ebsrXml, hasXPath("count(/itemResponse/response[@id='EBSR2']/value)", equalTo("1")));
        assertThat(ebsrXml, hasXPath("/itemResponse/response[@id='EBSR2']/value/text()", equalTo("A")));

        //MI
        final Source miXML = Input.fromString(getEmbeddedXml(doc, "//Response[@junit='mi']")).build();
        assertThat(miXML, hasXPath("count(/itemResponse/response)", equalTo("1")));
        assertThat(miXML, hasXPath("/itemResponse/response/@id", equalTo("RESPONSE")));
        assertThat(miXML, hasXPath("count(/itemResponse/response/value)", equalTo("5")));

        final List<String> miValues = new ArrayList<>();

        new JAXPXPathEngine()
                .selectNodes("/itemResponse/response/value/text()", miXML)
                .forEach(valueNode -> miValues.add(valueNode.getTextContent()));
        assertThat(miValues).containsExactly("1 a", "2 b", "3 b", "4 a", "5 a");

        //TI
        final Source tiXML = Input.fromString(getEmbeddedXml(doc, "//Response[@junit='ti']")).build();
        assertThat(tiXML, hasXPath("count(/responseSpec/responseTable/tr/th)", equalTo("11")));
        assertThat(tiXML, hasXPath("count(/responseSpec/responseTable/tr/td)", equalTo("11")));

        final List<String> tiValues = new ArrayList<>();
        new JAXPXPathEngine()
                .selectNodes("/responseSpec/responseTable/tr/td", tiXML)
                .forEach(valueNode -> tiValues.add(valueNode.getTextContent()));
        assertThat(tiValues).containsExactly("", "B", "", "", "A", "", "", "C", "", "", "D");

        //HTQ
        final Source htqXML = Input.fromString(getEmbeddedXml(doc, "//Response[@junit='htq']")).build();
        assertThat(htqXML, hasXPath("/itemResponse/response/@id", equalTo("1")));
        assertThat(htqXML, hasXPath("count(/itemResponse/response[@id='1']/value)", equalTo("2")));
        final List<String> htqValues = new ArrayList<>();

        new JAXPXPathEngine()
                .selectNodes("/itemResponse/response/value", htqXML)
                .forEach(valueNode -> htqValues.add(valueNode.getTextContent()));
        assertThat(htqValues).containsExactly("2", "4");

        //EQ
        final Source eqXML = Input.fromString(getEmbeddedXml(doc, "//Response[@junit='eq']")).build();
        final Node mathNode = StreamSupport.stream(new JAXPXPathEngine()
                .selectNodes("/response/*[name()='math']", eqXML)
                .spliterator(), false)
                .findFirst()
                .orElseThrow(() -> new NoSuchElementException("Cannot find EQ Math node"));
        assertThat(mathNode.getNamespaceURI()).isEqualTo("http://www.w3.org/1998/Math/MathML");
        assertThat(eqXML, hasXPath("/response/*[name()='math']/@title", equalTo("50")));
        assertThat(eqXML, hasXPath("/response/*[name()='math']/*[name()='mstyle']/*[name()='mn']/text()", equalTo("50")));

        //GI
        final Source giXML = Input.fromString(getEmbeddedXml(doc, "//Response[@junit='gi']")).build();
        assertThat(giXML, hasXPath("/AnswerSet/Question/QuestionPart/@id", equalTo("1")));
        final List<String> atomicObjectValues = StreamSupport.stream(new JAXPXPathEngine()
                .selectNodes("/AnswerSet/Question/QuestionPart/ObjectSet/AtomicObject", giXML)
                .spliterator(), false)
                .map(Node::getTextContent)
                .collect(Collectors.toList());
        assertThat(atomicObjectValues).containsExactly("{AminusB(91,49)}", "{BC(193,49)}", "{C(299,49)}");
        assertThat(giXML, hasXPath("/AnswerSet/Question/QuestionPart/ObjectSet/RegionGroupObject/@name", equalTo("PartA")));
        final List<String> regionObjectValues = StreamSupport.stream(new JAXPXPathEngine()
                .selectNodes("/AnswerSet/Question/QuestionPart/ObjectSet/RegionGroupObject/RegionObject/@name", giXML)
                .spliterator(), false)
                .map(Node::getTextContent)
                .collect(Collectors.toList());
        assertThat(regionObjectValues).containsExactly("Step1", "Step2", "Step3", "Step4");
        assertThat(giXML, hasXPath("/AnswerSet/Question/QuestionPart/SnapPoint/text()", equalTo("70@91,361;193,361;299,361;407,361;299,345;299,377")));

        //SA | ER | WER
        assertThat(getEmbeddedXml(doc, "//Response[@junit='wer']"))
                .contains("<p><strong><em><u>&nbsp;")
                .contains("classroom that they can&#39;t see,")
                .contains("their teacher&#39;s endless");
    }

    // Some of the Item types include escaped XML embedded into text values. This function parses
    // these values into regular XML, so it can be tested with XmlUnit assertions.
    private String getEmbeddedXml(Document d, String xpathExpression) throws Exception {
        XPathFactory factory = XPathFactory.newInstance();
        XPath xpath = factory.newXPath();
        XPathExpression expr = xpath.compile(xpathExpression);
        Object result = expr.evaluate(d, XPathConstants.NODE);
        Node node = (Node)result;
        return node.getTextContent();
    }

    private Matcher<String> isBlankString() {
        return new BaseMatcher<String>() {
            @Override
            public boolean matches ( final Object item){
                if (item == null) {
                    return true;
                }

                if (!(item instanceof String)) {
                    return false;
                }

                return StringUtils.isBlank((String) item);
            }

            @Override
            public void describeTo ( final Description description){
                description.appendText("a blank string");
            }
        };
    }
}
