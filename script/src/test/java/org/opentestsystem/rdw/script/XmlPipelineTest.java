package org.opentestsystem.rdw.script;

import org.apache.commons.lang3.RandomUtils;
import org.apache.commons.lang3.StringUtils;
import org.hamcrest.BaseMatcher;
import org.hamcrest.Description;
import org.hamcrest.Matcher;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.Mock;
import org.mockito.junit.MockitoJUnitRunner;
import org.opentestsystem.rdw.script.impl.DefaultConfigurationCompiler;
import org.opentestsystem.rdw.script.impl.EmptyPropertyResolver;
import org.opentestsystem.rdw.script.impl.ResourceLoaderScriptSource;
import org.opentestsystem.rdw.script.publishing.PublishedPipelineRepository;
import org.opentestsystem.rdw.script.security.AbstractToggleableSecurityManager;
import org.opentestsystem.rdw.script.security.DefaultSandboxSecurityManager;
import org.opentestsystem.rdw.script.security.DefaultSandboxPermissions;
import org.w3c.dom.Document;
import org.w3c.dom.Node;
import org.xml.sax.InputSource;
import org.xmlunit.builder.Input;
import org.xmlunit.xpath.JAXPXPathEngine;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.transform.Source;
import javax.xml.xpath.XPath;
import javax.xml.xpath.XPathConstants;
import javax.xml.xpath.XPathExpression;
import javax.xml.xpath.XPathFactory;
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.NoSuchElementException;
import java.util.stream.Collectors;
import java.util.stream.StreamSupport;

import static org.assertj.core.api.Assertions.assertThat;
import static org.hamcrest.CoreMatchers.equalTo;
import static org.hamcrest.CoreMatchers.not;
import static org.junit.Assert.assertThat;
import static org.mockito.Mockito.when;
import static org.opentestsystem.rdw.script.util.Tests.resourceAsBytes;
import static org.opentestsystem.rdw.script.util.Tests.resourceAsString;
import static org.xmlunit.matchers.EvaluateXPathMatcher.hasXPath;

@RunWith(MockitoJUnitRunner.class)
public class XmlPipelineTest {
    private static final String PIPELINE_NAME = "My Test Pipeline";
    private static final String PIPELINE_VERSION = "1.0";

    private PipelineFactory pipelineFactory;
    private byte[] originalXml;
    private ScriptPipelineConfiguration config = new ScriptPipelineConfiguration();

    private static AbstractToggleableSecurityManager sandboxSecurityManager;

    @Mock
    private PublishedPipelineRepository repository;

    private PipelineDefinition pipelineDefinition;

    @BeforeClass
    public static void setupSecurityManager() {
        sandboxSecurityManager = new DefaultSandboxSecurityManager(new DefaultSandboxPermissions());
    }

    @Before
    public void before() throws Exception {

        pipelineDefinition = PipelineDefinition.builder()
                .pipelineCode(PIPELINE_NAME)
                .version(PIPELINE_VERSION)
                .scripts(Arrays.asList(
                        PipelineScriptDefinition.builder()
                                .type(PipelineScriptType.User)
                                .version("1.0")
                                .body("")
                                .build(),
                        PipelineScriptDefinition.builder()
                                .type(PipelineScriptType.Base)
                                .version("1.0")
                                .body(resourceAsString("/DSLScriptBase.groovy"))
                                .build()
                ))
                .build();

        when(repository.findByCodeAndVersion(PIPELINE_NAME, PIPELINE_VERSION))
                .thenReturn(pipelineDefinition);

        ConfigurationCompiler configurationCompiler = new DefaultConfigurationCompiler();
        PropertyResolver propertyResolver = new EmptyPropertyResolver();

        pipelineFactory = config.pipelineFactory(
                repository,
                configurationCompiler,
                propertyResolver,
                sandboxSecurityManager,
                new ResourceLoaderScriptSource() // TODO mock
        );

        originalXml = resourceAsBytes("/sample_xml/TDSReport.iab.2018_AIR_format.xml");
    }

    @Test
    public void itShouldTransformByScriptCommands() throws Exception {
        // Transform sample TRT file using the Groovy script commands with XML helper methods.
        // Test the results using equivalent tests to those in the Exam Processor module for testing
        // XSL transformation
        when(repository.findByCodeAndVersion(PIPELINE_NAME, PIPELINE_VERSION))
                .thenReturn(pipelineWithUserScriptPath("/scripts/exam_script.groovy"));

        Pipeline pipeline = pipelineFactory.getPipeline(PIPELINE_NAME, PIPELINE_VERSION);
        PipelineResults results = pipeline.run(originalXml);
        assertThat(results.isModified()).isTrue();

        verifyTransformedXml(results.asByteArray());
    }

    @Test(expected = ScriptRuntimeException.class)
    public void itShouldErrorOnDangerousScript() throws Exception {
        // Transform sample TRT file using the Groovy script commands with XML helper methods.
        // Test the results using equivalent tests to those in the Exam Processor module for testing
        // XSL transformation
        when(repository.findByCodeAndVersion(PIPELINE_NAME, PIPELINE_VERSION))
                .thenReturn(pipelineWithUserScriptPath("/scripts/exam_script_danger.groovy"));

        Pipeline pipeline = pipelineFactory.getPipeline(PIPELINE_NAME, PIPELINE_VERSION);
        pipeline.run(originalXml);
    }

    @Test
    public void itShouldTransformByXslScript() throws Exception {
        // Transform the same TRT file as above, but instead use a script that applies an XSL transformation
        // instead of Groovy commands for the transformation. Use the same tests to verify this transformation.
        when(repository.findByCodeAndVersion(PIPELINE_NAME, PIPELINE_VERSION))
                .thenReturn(pipelineWithUserScriptPath("/scripts/exam_script_xsl.groovy"));

        Pipeline pipeline = pipelineFactory.getPipeline(PIPELINE_NAME, PIPELINE_VERSION);
        PipelineResults results = pipeline.run(originalXml);
        assertThat(results.isModified()).isTrue();

        verifyTransformedXml(results.asByteArray());
    }

    @Test
    public void itShouldTransformByHybridScript() throws Exception {
        // Transform the same TRT file as above, but instead use a script that applies an XSL transformation
        // instead of Groovy commands for the transformation. Use the same tests to verify this transformation.
        when(repository.findByCodeAndVersion(PIPELINE_NAME, PIPELINE_VERSION))
                .thenReturn(pipelineWithUserScriptPath("/scripts/exam_script_hybrid.groovy"));

        Pipeline pipeline = pipelineFactory.getPipeline(PIPELINE_NAME, PIPELINE_VERSION);
        PipelineResults results = pipeline.run(originalXml);
        assertThat(results.isModified()).isTrue();

        verifyTransformedXml(results.asByteArray());
    }

    @Test
    public void itShouldFilterOutElements() throws Exception {
        // Test ability to filter out elements with a boolean rule. All elements matching the XPath expression
        // and also matching this rule will be removed.
        final String scriptCode =
                "enable 'xml'\n" +
                        "delete '//Item' when { item ->\n" +
                        "    item.key == '37115' || item.key == '92135'\n" +
                        "}\n" +
                        "outputXml";

        when(repository.findByCodeAndVersion(PIPELINE_NAME, PIPELINE_VERSION))
                .thenReturn(pipelineWithUserScript(scriptCode));

        assertThat(originalXml, hasXPath("//Item[@key='37115']", not(isBlankString())));
        assertThat(originalXml, hasXPath("//Item[@key='92135']", not(isBlankString())));

        Pipeline pipeline = pipelineFactory.getPipeline(PIPELINE_NAME, PIPELINE_VERSION);

        byte[] newXml = pipeline.run(originalXml).asByteArray();

        assertThat(newXml, hasXPath("//Item[@key='37115']", isBlankString()));
        assertThat(newXml, hasXPath("//Item[@key='92135']", isBlankString()));
    }

    @Test
    public void itShouldFilterInElements() throws Exception {
        // Test filter in with a boolean rule. All elements matching the XPath expression, but not matching the rule
        // will be removed.
        String scriptCode =
                "enable 'xml'\n" +
                        "delete '//Item' unless { item ->\n" +
                        "    item.key == '37115'\n" +
                        "}\n" +
                        "outputXml";

        when(repository.findByCodeAndVersion(PIPELINE_NAME, PIPELINE_VERSION))
                .thenReturn(pipelineWithUserScript(scriptCode));

        assertThat(originalXml, hasXPath("//Item[@key='37115']", not(isBlankString())));

        Pipeline pipeline = pipelineFactory.getPipeline(PIPELINE_NAME, PIPELINE_VERSION);
        byte[] newXml = pipeline.run(originalXml).asByteArray();

        assertThat(newXml, hasXPath("//Item[not(@key='37115')]", isBlankString()));
    }

    @Test
    public void isShouldReportNoModifications() throws Exception {
        final byte [] input = RandomUtils.nextBytes(1000);

        final String scriptCode =  "return input.clone()";

        when(repository.findByCodeAndVersion(PIPELINE_NAME, PIPELINE_VERSION))
                .thenReturn(pipelineWithUserScript(scriptCode));

        final Pipeline pipeline = pipelineFactory.getPipeline(PIPELINE_NAME, PIPELINE_VERSION);
        final PipelineResults results = pipeline.run(input);
        assertThat(results.isModified()).isFalse();
    }

    // Used by the various transform tests
    private void verifyTransformedXml(byte[] xml) throws Exception {

        //
        // Item Bank Key transformation 10200 --> 200
        //
        assertThat(xml, hasXPath("//Item/@bankKey", equalTo("200")));
        assertThat(xml, not(hasXPath("//Item/@bankKey", equalTo("10200"))));

        //
        // Several response transformations based on type:
        //

        // MC
        assertThat(xml, hasXPath("//Response[@junit='mc']/text()", equalTo("A")));

        // MS
        assertThat(xml, hasXPath("//Response[@junit='ms']/text()", equalTo("A,C,D")));


        DocumentBuilder db = DocumentBuilderFactory.newInstance().newDocumentBuilder();
        InputSource is = new InputSource(new ByteArrayInputStream(xml));
        Document doc = db.parse(is);


        //EBSR
        final String ebsrXml = getEmbeddedXml(doc, "//Response[@junit='ebsr']");
        assertThat(ebsrXml, hasXPath("count(/itemResponse/response)", equalTo("2")));
        assertThat(ebsrXml, hasXPath("count(/itemResponse/response[@id='EBSR1']/value)", equalTo("1")));
        assertThat(ebsrXml, hasXPath("/itemResponse/response[@id='EBSR1']/value/text()", equalTo("B")));
        assertThat(ebsrXml, hasXPath("count(/itemResponse/response[@id='EBSR2']/value)", equalTo("1")));
        assertThat(ebsrXml, hasXPath("/itemResponse/response[@id='EBSR2']/value/text()", equalTo("A")));

        //MI
        final Source miXML = Input.fromString(getEmbeddedXml(doc, "//Response[@junit='mi']")).build();
        assertThat(miXML, hasXPath("count(/itemResponse/response)", equalTo("1")));
        assertThat(miXML, hasXPath("/itemResponse/response/@id", equalTo("RESPONSE")));
        assertThat(miXML, hasXPath("count(/itemResponse/response/value)", equalTo("5")));

        final List<String> miValues = new ArrayList<>();

        new JAXPXPathEngine()
                .selectNodes("/itemResponse/response/value/text()", miXML)
                .forEach(valueNode -> miValues.add(valueNode.getTextContent()));
        assertThat(miValues).containsExactly("1 a", "2 b", "3 b", "4 a", "5 a");

        //TI
        final Source tiXML = Input.fromString(getEmbeddedXml(doc, "//Response[@junit='ti']")).build();
        assertThat(tiXML, hasXPath("count(/responseSpec/responseTable/tr/th)", equalTo("11")));
        assertThat(tiXML, hasXPath("count(/responseSpec/responseTable/tr/td)", equalTo("11")));

        final List<String> tiValues = new ArrayList<>();
        new JAXPXPathEngine()
                .selectNodes("/responseSpec/responseTable/tr/td", tiXML)
                .forEach(valueNode -> tiValues.add(valueNode.getTextContent()));
        assertThat(tiValues).containsExactly("", "B", "", "", "A", "", "", "C", "", "", "D");

        //HTQ
        final Source htqXML = Input.fromString(getEmbeddedXml(doc, "//Response[@junit='htq']")).build();
        assertThat(htqXML, hasXPath("/itemResponse/response/@id", equalTo("1")));
        assertThat(htqXML, hasXPath("count(/itemResponse/response[@id='1']/value)", equalTo("2")));
        final List<String> htqValues = new ArrayList<>();

        new JAXPXPathEngine()
                .selectNodes("/itemResponse/response/value", htqXML)
                .forEach(valueNode -> htqValues.add(valueNode.getTextContent()));
        assertThat(htqValues).containsExactly("2", "4");

        //EQ
        final Source eqXML = Input.fromString(getEmbeddedXml(doc, "//Response[@junit='eq']")).build();
        final Node mathNode = StreamSupport.stream(new JAXPXPathEngine()
                .selectNodes("/response/*[name()='math']", eqXML)
                .spliterator(), false)
                .findFirst()
                .orElseThrow(() -> new NoSuchElementException("Cannot find EQ Math node"));
        assertThat(mathNode.getNamespaceURI()).isEqualTo("http://www.w3.org/1998/Math/MathML");
        assertThat(eqXML, hasXPath("/response/*[name()='math']/@title", equalTo("50")));
        assertThat(eqXML, hasXPath("/response/*[name()='math']/*[name()='mstyle']/*[name()='mn']/text()", equalTo("50")));

        //GI
        final Source giXML = Input.fromString(getEmbeddedXml(doc, "//Response[@junit='gi']")).build();
        assertThat(giXML, hasXPath("/AnswerSet/Question/QuestionPart/@id", equalTo("1")));
        final List<String> atomicObjectValues = StreamSupport.stream(new JAXPXPathEngine()
                .selectNodes("/AnswerSet/Question/QuestionPart/ObjectSet/AtomicObject", giXML)
                .spliterator(), false)
                .map(Node::getTextContent)
                .collect(Collectors.toList());
        assertThat(atomicObjectValues).containsExactly("{AminusB(91,49)}", "{BC(193,49)}", "{C(299,49)}");
        assertThat(giXML, hasXPath("/AnswerSet/Question/QuestionPart/ObjectSet/RegionGroupObject/@name", equalTo("PartA")));
        final List<String> regionObjectValues = StreamSupport.stream(new JAXPXPathEngine()
                .selectNodes("/AnswerSet/Question/QuestionPart/ObjectSet/RegionGroupObject/RegionObject/@name", giXML)
                .spliterator(), false)
                .map(Node::getTextContent)
                .collect(Collectors.toList());
        assertThat(regionObjectValues).containsExactly("Step1", "Step2", "Step3", "Step4");
        assertThat(giXML, hasXPath("/AnswerSet/Question/QuestionPart/SnapPoint/text()", equalTo("70@91,361;193,361;299,361;407,361;299,345;299,377")));

        //SA | ER | WER
        assertThat(getEmbeddedXml(doc, "//Response[@junit='wer']"))
                .contains("<p><strong><em><u>&nbsp;")
                .contains("classroom that they can&#39;t see,")
                .contains("their teacher&#39;s endless");
    }

    // Some of the Item types include escaped XML embedded into text values. This function parses
    // these values into regular XML, so it can be tested with XmlUnit assertions.
    private String getEmbeddedXml(Document d, String xpathExpression) throws Exception {
        XPathFactory factory = XPathFactory.newInstance();
        XPath xpath = factory.newXPath();
        XPathExpression expr = xpath.compile(xpathExpression);
        Object result = expr.evaluate(d, XPathConstants.NODE);
        Node node = (Node) result;
        return node.getTextContent();
    }

    private Matcher<String> isBlankString() {
        return new BaseMatcher<String>() {
            @Override
            public boolean matches(final Object item) {
                if (item == null) {
                    return true;
                }

                if (!(item instanceof String)) {
                    return false;
                }

                return StringUtils.isBlank((String) item);
            }

            @Override
            public void describeTo(final Description description) {
                description.appendText("a blank string");
            }
        };
    }

    private PipelineDefinition pipelineWithUserScriptPath(final String userScriptPath) throws IOException {
        return pipelineWithUserScript(
                resourceAsString(userScriptPath)
        );
    }

    private PipelineDefinition pipelineWithUserScript(final String userScript) throws IOException {
        return PipelineDefinition.builder()
                .pipelineCode(PIPELINE_NAME)
                .version(PIPELINE_VERSION)
                .scripts(Arrays.asList(
                        PipelineScriptDefinition.builder()
                                .type(PipelineScriptType.User)
                                .version("1.0")
                                .body(userScript)
                                .build(),
                        PipelineScriptDefinition.builder()
                                .type(PipelineScriptType.Base)
                                .version("1.0")
                                .body(resourceAsString("/DSLScriptBase.groovy"))
                                .build()
                ))
                .build();
    }

}
