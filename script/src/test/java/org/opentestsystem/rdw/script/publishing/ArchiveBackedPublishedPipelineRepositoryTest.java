
package org.opentestsystem.rdw.script.publishing;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.ArgumentCaptor;
import org.mockito.Mock;
import org.mockito.junit.MockitoJUnitRunner;

import java.time.Instant;
import java.util.List;
import java.util.Properties;

import static com.google.common.collect.Lists.newArrayList;
import static java.nio.charset.StandardCharsets.UTF_8;
import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;


@RunWith(MockitoJUnitRunner.class)
public class ArchiveBackedPublishedPipelineRepositoryTest {

    @Mock
    private org.opentestsystem.rdw.archive.ArchiveService archiveService;
    private ObjectMapper objectMapper;
    private ArchiveBackedPublishedPipelineRepository repository;

    @Before
    public void before() {
        objectMapper = new ObjectMapper();
        objectMapper.registerModule(new JavaTimeModule());

        repository = new ArchiveBackedPublishedPipelineRepository(
                archiveService,
                objectMapper
        );
    }

    @Test
    public void findAllByCodeShouldReturnNothingWhenEmpty() {
        final List<PublishedPipeline> publishedPipelines = repository.findAllByCode("code");
        assertThat(publishedPipelines).isEmpty();
        verify(archiveService).listResources("pipelines/code");
    }

    @Test
    public void findAllByCodeShouldCallArchiveService() throws Exception {

        final String pipelineCode = "code";
        final String pipelinePathPrefix = "pipelines/" + pipelineCode;
        final String pipelinePath = "pipelines/" + pipelineCode + "/pipeline.1.json";
        final PipelineResource pipelineResource = PipelineResource.builder()
                .pipelineCode(pipelineCode)
                .version("1")
                .published(Instant.now())
                .publishedBy("publisher")
                .build();
        final byte[] pipelineResourceAsString = objectMapper.writeValueAsBytes(pipelineResource);

        when(archiveService.listResources(pipelinePathPrefix))
                .thenReturn(newArrayList(
                        pipelinePath
                ));

        when(archiveService.readResource(pipelinePath))
                .thenReturn(pipelineResourceAsString);

        assertThat(repository.findAllByCode(pipelineCode))
                .usingRecursiveFieldByFieldElementComparator()
                .containsExactly(
                        PublishedPipeline.builder()
                                .pipelineCode(pipelineResource.getPipelineCode())
                                .version(pipelineResource.getVersion())
                                .published(pipelineResource.getPublished())
                                .publishedBy(pipelineResource.getPublishedBy())
                                .build()
                );
    }

    @Test
    public void findByCodeAndVersionShouldReturnNullWhenAbsent() {
        assertThat(repository.findByCodeAndVersion("code", "1")).isNull();
    }

    @Test
    public void findByCodeAndVersionShouldFind() throws Exception {

        final String pipelineCode = "code";
        final String pipelineVersion = "5";
        final String pipelinePath = "pipelines/" + pipelineCode + "/pipeline." + pipelineVersion + ".json";
        final PipelineResource pipelineResource = PipelineResource.builder()
                .pipelineCode(pipelineCode)
                .version(pipelineVersion)
                .published(Instant.now())
                .publishedBy("publisher")
                .build();

        final byte[] pipelineResourceAsString = objectMapper.writeValueAsBytes(pipelineResource);

        when(archiveService.exists(pipelinePath))
                .thenReturn(true);

        when(archiveService.readResource(pipelinePath))
                .thenReturn(pipelineResourceAsString);

        assertThat(repository.findByCodeAndVersion(pipelineCode, pipelineVersion))
                .isEqualToComparingFieldByFieldRecursively(
                        PublishedPipeline.builder()
                                .pipelineCode(pipelineResource.getPipelineCode())
                                .version(pipelineResource.getVersion())
                                .published(pipelineResource.getPublished())
                                .publishedBy(pipelineResource.getPublishedBy())
                                .build()
                );
    }

    @Test
    public void findByCodeAndVersionShouldLoadScriptsIfPresent() throws Exception {

        final String pipelineCode = "code";
        final String pipelineVersion = "5";
        final String pipelinePath = "pipelines/" + pipelineCode + "/pipeline." + pipelineVersion + ".json";
        final String userScriptPath = "pipelines/" + pipelineCode + "/user." + pipelineVersion + ".groovy";
        final String baseScriptPath = "pipelines/" + pipelineCode + "/base.Base.groovy";
        final String preScriptPath = "pipelines/" + pipelineCode + "/pre-process.Pre.groovy";
        final String postScriptPath = "pipelines/" + pipelineCode + "/post-process.Post.groovy";
        final PipelineResource pipelineResource = PipelineResource.builder()
                .pipelineCode(pipelineCode)
                .version(pipelineVersion)
                .published(Instant.now())
                .publishedBy("publisher")
                .userScriptVersion(pipelineVersion)
                .baseScriptVersion("Base")
                .preProcessScriptVersion("Pre")
                .postProcessScriptVersion("Post")
                .build();

        final byte[] pipelineResourceAsString = objectMapper.writeValueAsBytes(pipelineResource);

        when(archiveService.exists(pipelinePath)).thenReturn(true);
        when(archiveService.readResource(pipelinePath)).thenReturn(pipelineResourceAsString);

        when(archiveService.exists(userScriptPath)).thenReturn(true);
        when(archiveService.readResource(userScriptPath)).thenReturn("user script body".getBytes(UTF_8));

        when(archiveService.exists(baseScriptPath)).thenReturn(true);
        when(archiveService.readResource(baseScriptPath)).thenReturn("base script body".getBytes(UTF_8));

        when(archiveService.exists(preScriptPath)).thenReturn(true);
        when(archiveService.readResource(preScriptPath)).thenReturn("pre script body".getBytes(UTF_8));

        when(archiveService.exists(postScriptPath)).thenReturn(true);
        when(archiveService.readResource(postScriptPath)).thenReturn("post script body".getBytes(UTF_8));

        assertThat(repository.findByCodeAndVersion(pipelineCode, pipelineVersion))
                .isEqualToComparingFieldByFieldRecursively(
                        PublishedPipeline.builder()
                                .pipelineCode(pipelineResource.getPipelineCode())
                                .version(pipelineResource.getVersion())
                                .published(pipelineResource.getPublished())
                                .publishedBy(pipelineResource.getPublishedBy())
                                .scripts(newArrayList(
                                        PublishedScript.builder()
                                                .type(ScriptType.User)
                                                .version(pipelineVersion)
                                                .body("user script body")
                                                .build(),
                                        PublishedScript.builder()
                                                .type(ScriptType.Base)
                                                .version("Base")
                                                .body("base script body")
                                                .build(),
                                        PublishedScript.builder()
                                                .type(ScriptType.Pre)
                                                .version("Pre")
                                                .body("pre script body")
                                                .build(),
                                        PublishedScript.builder()
                                                .type(ScriptType.Post)
                                                .version("Post")
                                                .body("post script body")
                                                .build()
                                ))
                                .build()
                );
    }


    @Test(expected = IllegalStateException.class)
    public void findByCodeAndVersionShouldThrowExceptionWhenMisconfigured() throws Exception {
        final String pipelineCode = "code";
        final String pipelineVersion = "5";
        final String pipelinePath = "pipelines/" + pipelineCode + "/pipeline." + pipelineVersion + ".json";
        final PipelineResource pipelineResource = PipelineResource.builder()
                .pipelineCode(pipelineCode)
                .version(pipelineVersion)
                .published(Instant.now())
                .publishedBy("publisher")
                .userScriptVersion(pipelineVersion)
                .build();

        final byte[] pipelineResourceAsString = objectMapper.writeValueAsBytes(pipelineResource);

        when(archiveService.exists(pipelinePath)).thenReturn(true);
        when(archiveService.readResource(pipelinePath)).thenReturn(pipelineResourceAsString);

        repository.findByCodeAndVersion(pipelineCode, pipelineVersion);
    }

    @Test
    public void createShouldStartVersionAtOne() {
        final String pipelineCode = "code";
        final String pipelinePathPrefix = "pipelines/" + pipelineCode;

        when(archiveService.listResources(pipelinePathPrefix))
                .thenReturn(newArrayList());

        assertThat(repository.create(
                PublishedPipeline.builder()
                        .pipelineCode(pipelineCode)
                        .build()
        ).getVersion()).isEqualTo("1");
    }

    @Test
    public void createShouldBumpVersion() throws Exception {

        final String pipelineCode = "code";
        final String pipelinePathPrefix = "pipelines/" + pipelineCode;
        final String pipelinePath = "pipelines/" + pipelineCode + "/pipeline.1.json";
        final PipelineResource pipelineResource = PipelineResource.builder()
                .pipelineCode(pipelineCode)
                .version("1")
                .published(Instant.now())
                .publishedBy("publisher")
                .build();
        final byte[] pipelineResourceAsString = objectMapper.writeValueAsBytes(pipelineResource);

        when(archiveService.listResources(pipelinePathPrefix))
                .thenReturn(newArrayList(
                        pipelinePath
                ));

        when(archiveService.readResource(pipelinePath))
                .thenReturn(pipelineResourceAsString);

        assertThat(repository.create(
                PublishedPipeline.builder()
                        .pipelineCode(pipelineCode)
                        .build()
        ).getVersion()).isEqualTo("2");
    }

    @Test
    public void createShouldWritePipeline() {

        final PublishedPipeline pipeline = PublishedPipeline.builder()
                .pipelineCode("code")
                .build();

        repository.create(pipeline);

        final ArgumentCaptor<String> path = ArgumentCaptor.forClass(String.class);
        final ArgumentCaptor<byte[]> resource = ArgumentCaptor.forClass(byte[].class);
        final ArgumentCaptor<Properties> properties = ArgumentCaptor.forClass(Properties.class);
        verify(archiveService).writeResource(path.capture(), resource.capture(), properties.capture());

        assertThat(path.getValue()).isEqualTo("pipelines/code/pipeline.1.json");
        assertThat(resource.getValue()).isNotNull().isNotEmpty();
        assertThat(properties.getValue()).isNull();
    }

    @Test
    public void createShouldNotWriteUserScriptIfAbsent() {

        final PublishedPipeline pipeline = PublishedPipeline.builder()
                .pipelineCode("code")
                .build();

        repository.create(pipeline);

        final ArgumentCaptor<String> path = ArgumentCaptor.forClass(String.class);
        final ArgumentCaptor<byte[]> resource = ArgumentCaptor.forClass(byte[].class);
        final ArgumentCaptor<Properties> properties = ArgumentCaptor.forClass(Properties.class);
        verify(archiveService).writeResource(path.capture(), resource.capture(), properties.capture());

        assertThat(path.getAllValues()).doesNotContain("pipelines/code/user.1.groovy");
    }

    @Test
    public void createShouldWriteUserScriptIfPresent() {

        final PublishedPipeline pipeline = PublishedPipeline.builder()
                .pipelineCode("code")
                .scripts(newArrayList(
                        PublishedScript.builder()
                                .type(ScriptType.User)
                                .body("body")
                                .build()
                ))
                .build();

        repository.create(pipeline);

        final ArgumentCaptor<String> path = ArgumentCaptor.forClass(String.class);
        final ArgumentCaptor<byte[]> resource = ArgumentCaptor.forClass(byte[].class);
        final ArgumentCaptor<Properties> properties = ArgumentCaptor.forClass(Properties.class);
        verify(archiveService, times(2))
                .writeResource(path.capture(), resource.capture(), properties.capture());

        assertThat(path.getAllValues()).contains("pipelines/code/user.1.groovy");
    }

    @Test
    public void createShouldNotWriteSystemScriptsButOnlyWriteTheirVersions() throws Exception {

        final PublishedPipeline pipeline = PublishedPipeline.builder()
                .pipelineCode("code")
                .scripts(newArrayList(
                        PublishedScript.builder()
                                .type(ScriptType.Base)
                                .version("Base")
                                .body("Base")
                                .build(),
                        PublishedScript.builder()
                                .type(ScriptType.Pre)
                                .version("Pre")
                                .body("Pre")
                                .build(),
                        PublishedScript.builder()
                                .type(ScriptType.Post)
                                .version("Post")
                                .body("Post")
                                .build()
                ))
                .build();

        repository.create(pipeline);

        final ArgumentCaptor<String> path = ArgumentCaptor.forClass(String.class);
        final ArgumentCaptor<byte[]> resource = ArgumentCaptor.forClass(byte[].class);
        final ArgumentCaptor<Properties> properties = ArgumentCaptor.forClass(Properties.class);
        verify(archiveService)
                .writeResource(path.capture(), resource.capture(), properties.capture());

        final PipelineResource deserializedResource = objectMapper.readValue(resource.getValue(), PipelineResource.class);

        assertThat(deserializedResource.getUserScriptVersion()).isNull();
        assertThat(deserializedResource.getBaseScriptVersion()).isEqualTo("Base");
        assertThat(deserializedResource.getPreProcessScriptVersion()).isEqualTo("Pre");
        assertThat(deserializedResource.getPostProcessScriptVersion()).isEqualTo("Post");
    }

    @Test
    public void createShouldMapToAPipelineResourceCorrectly() throws Exception {

        final PublishedPipeline pipeline = PublishedPipeline.builder()
                .pipelineCode("code")
                .publishedBy("publisher")
                .scripts(newArrayList(
                        PublishedScript.builder()
                                .type(ScriptType.Base)
                                .version("Base")
                                .body("Base")
                                .build(),
                        PublishedScript.builder()
                                .type(ScriptType.Pre)
                                .version("Pre")
                                .body("Pre")
                                .build(),
                        PublishedScript.builder()
                                .type(ScriptType.Post)
                                .version("Post")
                                .body("Post")
                                .build()
                ))
                .build();

        repository.create(pipeline);

        final ArgumentCaptor<String> path = ArgumentCaptor.forClass(String.class);
        final ArgumentCaptor<byte[]> resource = ArgumentCaptor.forClass(byte[].class);
        final ArgumentCaptor<Properties> properties = ArgumentCaptor.forClass(Properties.class);
        verify(archiveService)
                .writeResource(path.capture(), resource.capture(), properties.capture());

        final PipelineResource deserializedResource = objectMapper.readValue(resource.getValue(), PipelineResource.class);

        assertThat(deserializedResource).isEqualToIgnoringGivenFields(
                PipelineResource.builder()
                        .pipelineCode(pipeline.getPipelineCode())
                        .version("1")
                        .publishedBy(pipeline.getPublishedBy())
                        .userScriptVersion(null)
                        .baseScriptVersion("Base")
                        .preProcessScriptVersion("Pre")
                        .postProcessScriptVersion("Post")
                        .build(),
                "published"
        );
    }

}