package org.opentestsystem.rdw.script;

import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.ExpectedException;
import org.junit.runner.RunWith;
import org.mockito.Mock;
import org.mockito.junit.MockitoJUnitRunner;
import org.opentestsystem.rdw.script.impl.DefaultPipelineFactory;
import org.opentestsystem.rdw.script.publishing.PublishedPipelineRepository;
import org.opentestsystem.rdw.script.security.DefaultSandboxSecurityManager;

import java.util.Arrays;
import java.util.Optional;
import java.util.stream.Collectors;

import static com.google.common.collect.Lists.newArrayList;
import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.Mockito.when;
import static org.opentestsystem.rdw.script.PipelineScriptType.Base;
import static org.opentestsystem.rdw.script.PipelineScriptType.Post;
import static org.opentestsystem.rdw.script.PipelineScriptType.Pre;
import static org.opentestsystem.rdw.script.PipelineScriptType.User;
import static org.opentestsystem.rdw.script.util.Tests.baseScript;

@RunWith(MockitoJUnitRunner.class)
public class DefaultPipelineFactoryTest {

    private static final PipelineScriptDefinition NonCompilingScript = PipelineScriptDefinition.builder()
            .body("new NoSuchThing()")
            .build();

    @Mock
    private PublishedPipelineRepository repository;

    @Mock
    private ConfigurationCompiler configurationCompiler;

    @Mock
    private PropertyResolver propertyResolver;

    @Mock
    private DefaultSandboxSecurityManager sandboxSecurityManager;

    @Mock
    private ScriptSource scriptSource;

    @Rule
    public ExpectedException exception = ExpectedException.none();

    private PipelineFactory factory;
    private PipelineDefinition pipelineDefinition;
    private PipelineScriptDefinition userScript;
    private PipelineScriptDefinition baseScript;
    private PipelineScriptDefinition preScript;
    private PipelineScriptDefinition postScript;

    @Before
    public void before() {

        final String pipelineVersion = "v";

        userScript = PipelineScriptDefinition.builder()
                .type(User)
                .body("")
                .version(pipelineVersion)
                .build();
        baseScript = baseScript();
        preScript = PipelineScriptDefinition.builder()
                .type(Pre)
                .body("pre script body")
                .build();
        postScript = PipelineScriptDefinition.builder()
                .type(Post)
                .body("post script body")
                .build();

        pipelineDefinition = PipelineDefinition.builder()
                .pipelineCode("test")
                .version(pipelineVersion)
                .scripts(Arrays.asList(
                        userScript
                ))
                .build();

        factory = new DefaultPipelineFactory(
                repository,
                configurationCompiler,
                propertyResolver,
                sandboxSecurityManager,
                scriptSource
        );


        when(scriptSource.getScript(Base, pipelineDefinition.getPipelineCode()))
                .thenReturn(Optional.of(baseScript));

        when(scriptSource.getScript(Pre, pipelineDefinition.getPipelineCode()))
                .thenReturn(Optional.of(preScript));

        when(scriptSource.getScript(Post, pipelineDefinition.getPipelineCode()))
                .thenReturn(Optional.of(postScript));
    }

    @Test
    public void getPipelineShouldComposeAPipelineFromAPublishedPipeline() {

        when(repository.findByCodeAndVersion(pipelineDefinition.getPipelineCode(), pipelineDefinition.getVersion()))
                .thenReturn(pipelineDefinition);

        final Pipeline pipeline = factory.getPipeline(pipelineDefinition.getPipelineCode(), pipelineDefinition.getVersion());
        assertThat(pipeline.getSource())
                .isEqualToComparingFieldByFieldRecursively(
                        pipelineDefinition.copy()
                                .scripts(Arrays.asList(
                                        userScript,
                                        baseScript,
                                        preScript,
                                        postScript
                                ))
                );
    }

    @Test
    public void getPipelineShouldComposeAPipelineFromSystemScriptsWhenAPublishedPipelineIsAbsent() {
        final Pipeline pipeline = factory.getPipeline(pipelineDefinition.getPipelineCode(), null);
        assertThat(pipeline.getSource())
                .isEqualToComparingFieldByFieldRecursively(
                        pipelineDefinition.copy()
                                .version(null)
                                .scripts(Arrays.asList(
                                        baseScript,
                                        preScript,
                                        postScript
                                ))
                                .build()
                );
    }

    @Test
    public void getPipelineShouldAddSystemScriptsOnlyWhenPresent() {

        when(scriptSource.getScript(Pre, pipelineDefinition.getPipelineCode()))
                .thenReturn(Optional.empty());

        when(scriptSource.getScript(Post, pipelineDefinition.getPipelineCode()))
                .thenReturn(Optional.empty());

        final Pipeline pipeline = factory.getPipeline(pipelineDefinition.getPipelineCode(), null);
        assertThat(pipeline.getSource())
                .isEqualToComparingFieldByFieldRecursively(
                        pipelineDefinition.copy()
                                .version(null)
                                .scripts(newArrayList(
                                        baseScript
                                ))
                                .build()
                );
    }

    @Test(expected = IllegalStateException.class)
    public void getPipelineShouldThrowExceptionWhenBaseClassIsNotConfigured() {

        when(scriptSource.getScript(Base, pipelineDefinition.getPipelineCode()))
                .thenReturn(Optional.empty());

        factory.getPipeline(pipelineDefinition.getPipelineCode(), null);
    }

    @Test(expected = IllegalStateException.class)
    public void getDevelopmentPipelineShouldThrowExceptionWhenBaseClassIsNotConfigured() {

        when(scriptSource.getScript(Base, pipelineDefinition.getPipelineCode()))
                .thenReturn(Optional.empty());

        factory.getPipeline(pipelineDefinition.getPipelineCode(), null);
    }

    @Test(expected = IllegalArgumentException.class)
    public void getPipelineShouldThrowExceptionWhenVersionIsSpecifiedByAPipelineOfThatVersionIsNotFound() {
        factory.getPipeline(pipelineDefinition.getPipelineCode(), pipelineDefinition.getVersion());
    }

    @Test
    public void getPipelineShouldCorrectlyCompileAndComposeAllNonBaseScripts() {
        when(repository.findByCodeAndVersion(pipelineDefinition.getPipelineCode(), pipelineDefinition.getVersion()))
                .thenReturn(pipelineDefinition);

        final Pipeline pipeline = factory.getPipeline(pipelineDefinition.getPipelineCode(), pipelineDefinition.getVersion());

        assertThat(pipeline.getSource())
                .isEqualToComparingFieldByFieldRecursively(
                        pipelineDefinition.copy()
                                .scripts(newArrayList(
                                        userScript,
                                        baseScript,
                                        preScript,
                                        postScript
                                ))
                                .build()
                );

        // base script is not included
        assertThat(pipeline.getScripts().size()).isEqualTo(3);

        assertThat(pipeline.getScripts().stream().map(PipelineScript::getSource).collect(Collectors.toList()))
                .usingRecursiveFieldByFieldElementComparator()
                .containsExactly(userScript, preScript, postScript);

        // check that the properties are set correctly
        for (final PipelineScript script : pipeline.getScripts()) {

            // this is set when running - this actually throws so it needs its own test
//            assertThat(script.getProperty("input"));

            // this is only set for system scripts
            if (script.getSource().getType().isSystemScript()) {
                assertThat(script.getProperty("propertyResolver")).isNotNull();
            } else {
                assertThat(script.getProperty("propertyResolver")).isNull();
            }
        }

    }

    @Test(expected = PipelineBuildException.class)
    public void getPipelineShouldThrowExceptionWhenUserScriptDoesntCompile() {
        when(repository.findByCodeAndVersion(pipelineDefinition.getPipelineCode(), pipelineDefinition.getVersion()))
                .thenReturn(pipelineDefinition.copy()
                        .scripts(newArrayList(
                                NonCompilingScript
                        ))
                        .build()
                );

        factory.getPipeline(pipelineDefinition.getPipelineCode(), pipelineDefinition.getVersion());
    }

    @Test(expected = PipelineBuildException.class)
    public void getPipelineShouldThrowExceptionWhenBaseScriptDoesntCompile() {
        when(scriptSource.getScript(Base, pipelineDefinition.getPipelineCode()))
                .thenReturn(Optional.of(
                        NonCompilingScript.copy().type(Base).build()
                ));

        factory.getPipeline(pipelineDefinition.getPipelineCode(), null);
    }

    @Test(expected = PipelineBuildException.class)
    public void getPipelineShouldThrowExceptionWhenPreScriptDoesntCompile() {
        when(scriptSource.getScript(Pre, pipelineDefinition.getPipelineCode()))
                .thenReturn(Optional.of(NonCompilingScript));

        factory.getPipeline(pipelineDefinition.getPipelineCode(), null);
    }

    @Test(expected = PipelineBuildException.class)
    public void getPipelineShouldThrowExceptionWhenPostScriptDoesntCompile() {
        when(scriptSource.getScript(Post, pipelineDefinition.getPipelineCode()))
                .thenReturn(Optional.of(NonCompilingScript));

        factory.getPipeline(pipelineDefinition.getPipelineCode(), null);
    }

    @Test(expected = PipelineBuildException.class)
    public void getDevelopmentPipelineShouldThrowExceptionWhenUserScriptDoesntCompile() {
        when(scriptSource.getScript(Base, pipelineDefinition.getPipelineCode()))
                .thenReturn(Optional.of(baseScript));

        factory.getDevelopmentPipeline(pipelineDefinition.getPipelineCode(), null, NonCompilingScript.getBody());
    }

    @Test(expected = PipelineBuildException.class)
    public void getDevelopmentPipelineShouldThrowExceptionWhenBaseScriptDoesntCompile() {
        when(scriptSource.getScript(Base, pipelineDefinition.getPipelineCode()))
                .thenReturn(Optional.of(
                        NonCompilingScript.copy().type(Base).build()
                ));

        factory.getDevelopmentPipeline(pipelineDefinition.getPipelineCode(), null, userScript.getBody());
    }

    @Test
    public void getDevelopmentPipelineShouldHaveFakeCodeAndNoSystemScripts() {
        when(scriptSource.getScript(Base, pipelineDefinition.getPipelineCode()))
                .thenReturn(Optional.of(baseScript));

        final Pipeline pipeline = factory.getDevelopmentPipeline(pipelineDefinition.getPipelineCode(), null, userScript.getBody());
        final PipelineScriptDefinition expectedUserScript = PipelineScriptDefinition.builder()
                .type(User)
                .body(userScript.getBody())
                .build();

        assertThat(pipeline.getSource())
                .isEqualToComparingFieldByFieldRecursively(
                        PipelineDefinition.builder()
                                .pipelineCode("Development Pipeline")
                                .scripts(newArrayList(
                                        expectedUserScript,
                                        baseScript
                                ))
                );

        // should not include base script
        assertThat(pipeline.getScripts().stream().map(PipelineScript::getSource).collect(Collectors.toList()))
                .usingRecursiveFieldByFieldElementComparator()
                .containsExactly(expectedUserScript);
    }

}
