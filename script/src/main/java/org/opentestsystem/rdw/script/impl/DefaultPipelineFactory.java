package org.opentestsystem.rdw.script.impl;

import org.opentestsystem.rdw.script.ConfigurationCompiler;
import org.opentestsystem.rdw.script.Pipeline;
import org.opentestsystem.rdw.script.PipelineBuildException;
import org.opentestsystem.rdw.script.PipelineDefinition;
import org.opentestsystem.rdw.script.PipelineFactory;
import org.opentestsystem.rdw.script.PipelineScript;
import org.opentestsystem.rdw.script.PipelineScriptDefinition;
import org.opentestsystem.rdw.script.PropertyResolver;
import org.opentestsystem.rdw.script.ScriptCompiler;
import org.opentestsystem.rdw.script.ScriptSource;
import org.opentestsystem.rdw.script.publishing.PublishedPipelineRepository;
import org.opentestsystem.rdw.script.security.SandboxSecurityManager;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import static com.google.common.collect.Lists.newArrayList;
import static java.util.stream.Collectors.toList;
import static org.opentestsystem.rdw.script.PipelineScriptType.Base;
import static org.opentestsystem.rdw.script.PipelineScriptType.Post;
import static org.opentestsystem.rdw.script.PipelineScriptType.Pre;
import static org.opentestsystem.rdw.script.PipelineScriptType.User;
import static org.opentestsystem.rdw.script.ScriptCompilers.toScriptCompiler;

/**
 * Factory class for creating a Pipeline by loading the pipeline definition and then using it to
 * load the script definitions for each node.
 */
public class DefaultPipelineFactory implements PipelineFactory {

    private final PublishedPipelineRepository repository;
    private final ConfigurationCompiler configCompiler;
    private final PropertyResolver propertyResolver;
    private final SandboxSecurityManager sandboxSecurityManager;
    private final ScriptSource scriptSource;

    public DefaultPipelineFactory(final PublishedPipelineRepository repository,
                                  final ConfigurationCompiler configCompiler,
                                  final PropertyResolver propertyResolver,
                                  final SandboxSecurityManager sandboxSecurityManager,
                                  final ScriptSource scriptSource) {
        this.repository = repository;
        this.configCompiler = configCompiler;
        this.propertyResolver = propertyResolver;
        this.sandboxSecurityManager = sandboxSecurityManager;
        this.scriptSource = scriptSource;
    }

    @Override
    public Pipeline getPipeline(
            final String pipelineCode,
            final String pipelineVersion) throws PipelineBuildException {

        return createPipeline(
                getEffectivePipeline(pipelineCode, pipelineVersion)
        );
    }

    @Override
    public Pipeline getDevelopmentPipeline(
            final String pipelineCode,
            final String pipelineVersion,
            final String userScript) {

        return createPipeline(
                createDevelopmentPipeline(pipelineCode, userScript)
        );
    }

    private PipelineDefinition getEffectivePipeline(
            final String pipelineCode,
            final String pipelineVersion) {

        if (pipelineVersion == null) {
            return PipelineDefinition.builder()
                    .pipelineCode(pipelineCode)
                    .scripts(getSystemScripts(pipelineCode))
                    .build();
        }

        final PipelineDefinition pipelineDefinition = repository
                .findByCodeAndVersion(pipelineCode, pipelineVersion);

        if (pipelineDefinition == null) {
            throw new IllegalArgumentException(String.format(
                    "Unable to build pipeline. There is no published pipeline with code \"%s\" and version \"%s\"",
                    pipelineCode,
                    pipelineVersion
            ));
        }

        final List<PipelineScriptDefinition> scripts = newArrayList(pipelineDefinition.getScripts());
        scripts.addAll(getSystemScripts(pipelineCode));

        return pipelineDefinition.copy()
                .scripts(scripts)
                .build();
    }

    private List<PipelineScriptDefinition> getSystemScripts(final String pipelineCode) {
        return newArrayList(
                PipelineScriptDefinition.builder().type(Base).build(),
                PipelineScriptDefinition.builder().type(Pre).build(),
                PipelineScriptDefinition.builder().type(Post).build()
        ).stream()
                .map(script -> script.copy()
                        .body(scriptSource.getScript(script.getType(), pipelineCode)
                                .map(PipelineScriptDefinition::getBody)
                                .orElse(null)
                        )
                        .build()
                )
                .filter(script -> script.getBody() != null)
                .collect(toList());
    }

    private PipelineDefinition createDevelopmentPipeline(
            final String pipelineCode,
            final String userScript) {

        final List<PipelineScriptDefinition> scripts = newArrayList(
                PipelineScriptDefinition.builder()
                        .type(User)
                        .body(userScript)
                        .build()
        );

        scriptSource.getScript(Base, pipelineCode)
                .ifPresent(scripts::add);

        return PipelineDefinition.builder()
                .pipelineCode("Development Pipeline")
                .scripts(scripts)
                .build();
    }


    private Pipeline createPipeline(final PipelineDefinition pipelineDefinition) throws PipelineBuildException {
        final Map<PipelineScriptDefinition, Exception> buildErrors = new HashMap<>();
        final List<PipelineScript> nonBasePipelineScripts = new ArrayList<>();

        final PipelineScriptDefinition baseScript = pipelineDefinition.getScripts().stream()
                .filter(script -> script.getType() == Base)
                .findFirst()
                .orElseThrow(() -> new IllegalStateException(String.format(
                        "Pipeline has no base script configured: %s",
                        pipelineDefinition
                )));

        try {
            final ScriptCompiler scriptCompiler = toScriptCompiler(baseScript.getBody());

            final List<PipelineScriptDefinition> nonBaseScripts = pipelineDefinition.getScripts().stream()
                    .filter(script -> script.getType() != Base)
                    .collect(toList());

            // For each node, load and compile the code and configuration and report back any errors.
            for (final PipelineScriptDefinition script : nonBaseScripts) {
                try {
                    final PipelineScript pipelineScript = toPipelineScript(
                            script,
                            scriptCompiler.compile(script.getBody()),
                            configCompiler.compile(Collections.emptyMap()),
                            script.getType().isSystemScript()
                                    ? propertyResolver
                                    : null
                    );

                    nonBasePipelineScripts.add(pipelineScript);
                } catch (final Exception exception) {
                    exception.fillInStackTrace();
                    buildErrors.put(script, exception);
                }
            }

        } catch (final Exception exception) {
            exception.fillInStackTrace();
            buildErrors.put(baseScript, exception);
        }

        if (!buildErrors.isEmpty()) {
            throw new PipelineBuildException(
                    String.format(
                            "Failed to build pipeline: %s v. %s",
                            pipelineDefinition.getPipelineCode(),
                            pipelineDefinition.getVersion()
                    ),
                    pipelineDefinition,
                    buildErrors
            );
        }

        // TODO
        // there is redundancy in storing script definitions on the pipeline definition
        // but then not using them and passing just the compiled non-base scripts to the pipeline
        return new Pipeline(
                pipelineDefinition,
                nonBasePipelineScripts,
                sandboxSecurityManager
        );
    }


    /**
     * Get an instance of the script to be run against the given input
     *
     * @return an instance of a PipelineScript
     * @throws Exception if there is an problem constructing the script
     */
    private PipelineScript toPipelineScript(
            final PipelineScriptDefinition source,
            final Class<? extends PipelineScript> scriptClass,
            final Map<String, Object> configuration,
            final PropertyResolver propertyResolver) throws Exception {
        final PipelineScript script = scriptClass.getConstructor().newInstance()
                .source(source)
                .bindProperties(configuration);

        if (propertyResolver != null) {
            script.setProperty("propertyResolver", propertyResolver);
        }

        return script;
    }

}
