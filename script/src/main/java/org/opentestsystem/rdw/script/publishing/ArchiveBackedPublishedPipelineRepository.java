
package org.opentestsystem.rdw.script.publishing;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.google.common.collect.ImmutableMap;
import org.springframework.stereotype.Service;

import java.io.IOException;
import java.time.Instant;
import java.util.List;
import java.util.Map;

import static com.google.common.collect.Lists.newArrayList;
import static java.nio.charset.StandardCharsets.UTF_8;
import static java.util.stream.Collectors.toList;
import static org.opentestsystem.rdw.script.publishing.ScriptType.Base;
import static org.opentestsystem.rdw.script.publishing.ScriptType.Post;
import static org.opentestsystem.rdw.script.publishing.ScriptType.Pre;
import static org.opentestsystem.rdw.script.publishing.ScriptType.User;

/**
 * Published pipeline repository implementation that stores the published pipelines using an archive service
 * <p>
 * The address structure for pipeline resources is organized as follows:
 * <p>
 * /{bucket}
 *  /pipelines
 *   /{pipelineCode} (assessment|exam|group)
 *    pipeline.{version}.json
 *    user.{version}.groovy
 *    base.{version}.groovy
 *    pre-process.{version}.groovy
 *    post-process.{version}.groovy
 */
@Service
public class ArchiveBackedPublishedPipelineRepository implements PublishedPipelineRepository {

    private static final Map<ScriptType, String> scriptPathPatternByType = ImmutableMap.<ScriptType, String>builder()
            .put(User, "pipelines/%s/user.%s.groovy")
            .put(Base, "pipelines/%s/base.%s.groovy")
            .put(Pre, "pipelines/%s/pre-process.%s.groovy")
            .put(Post, "pipelines/%s/post-process.%s.groovy")
            .build();

    private static String toPipelinesPathPrefix(final String pipelineCode) {
        return String.format(
                "pipelines/%s",
                pipelineCode
        );
    }

    private static String toPipelinePath(final String pipelineCode, final String pipelineVersion) {
        return String.format(
                "pipelines/%s/pipeline.%s.json",
                pipelineCode,
                pipelineVersion
        );
    }

    private static String toScriptPath(final ScriptType type, final String pipelineCode, final String version) {
        return String.format(
                scriptPathPatternByType.get(type),
                pipelineCode,
                version
        );
    }

    private final org.opentestsystem.rdw.archive.ArchiveService archiveService;
    private final ObjectMapper objectMapper;

    public ArchiveBackedPublishedPipelineRepository(
            final org.opentestsystem.rdw.archive.ArchiveService archiveService,
            final ObjectMapper objectMapper) {
        this.archiveService = archiveService;
        this.objectMapper = objectMapper;
    }

    @Override
    public List<PublishedPipeline> findAllByCode(final String code) {
        return archiveService.listResources(toPipelinesPathPrefix(code)).stream()
                .filter(path -> path.endsWith(".json"))
                .map(pipelineResourcePath -> {
                    final PipelineResource resource = deserialize(
                            archiveService.readResource(pipelineResourcePath),
                            PipelineResource.class
                    );
                    return PublishedPipeline.builder()
                            .pipelineCode(resource.getPipelineCode())
                            .version(resource.getVersion())
                            .published(resource.getPublished())
                            .publishedBy(resource.getPublishedBy())
                            .build();
                })
                .collect(toList());
    }

    @Override
    public PublishedPipeline findByCodeAndVersion(final String code, final String version) {
        final String path = toPipelinePath(code, version);

        if (!archiveService.exists(path)) {
            return null;
        }

        final PipelineResource resource = deserialize(
                archiveService.readResource(path),
                PipelineResource.class
        );

        final List<PublishedScript> scripts = newArrayList(
                PublishedScript.builder()
                        .type(User)
                        .version(resource.getUserScriptVersion())
                        .build(),
                PublishedScript.builder()
                        .type(Base)
                        .version(resource.getBaseScriptVersion())
                        .build(),
                PublishedScript.builder()
                        .type(Pre)
                        .version(resource.getPreProcessScriptVersion())
                        .build(),
                PublishedScript.builder()
                        .type(Post)
                        .version(resource.getPostProcessScriptVersion())
                        .build()
        ).stream()
                .filter(script -> script.getVersion() != null)
                .map(script ->
                        script.copy().body(
                                findScriptBody(code, version, script.getType(), script.getVersion())
                        ).build()
                )
                .collect(toList());

        return PublishedPipeline.builder()
                .pipelineCode(resource.getPipelineCode())
                .version(resource.getVersion())
                .scripts(scripts)
                .published(resource.getPublished())
                .publishedBy(resource.getPublishedBy())
                .build();
    }

    @Override
    public PublishedPipeline create(final PublishedPipeline pipeline) {

        final String nextVersion = Integer.toString(
                findAllByCode(pipeline.getPipelineCode())
                        .stream()
                        .mapToInt(published -> Integer.parseInt(published.getVersion()))
                        .max()
                        .orElse(0)
                        + 1
        );

        final PublishedPipeline published = pipeline.copy()
                .version(nextVersion)
                .published(Instant.now())
                .scripts(
                        pipeline.getScripts().stream()
                                .map(script ->
                                        script.getType() == User
                                                ? script.copy().version(nextVersion).build()
                                                : script
                                )
                                .collect(toList())
                )
                .build();

        final PipelineResource pipelineResource = PipelineResource.builder()
                .pipelineCode(published.getPipelineCode())
                .version(published.getVersion())
                .published(published.getPublished())
                .publishedBy(published.getPublishedBy())
                .userScriptVersion(
                        findScriptVersion(published.getScripts(), User)
                )
                .baseScriptVersion(
                        findScriptVersion(published.getScripts(), Base)
                )
                .preProcessScriptVersion(
                        findScriptVersion(published.getScripts(), Pre)
                )
                .postProcessScriptVersion(
                        findScriptVersion(published.getScripts(), Post)
                )
                .build();

        archiveService.writeResource(
                toPipelinePath(published.getPipelineCode(), published.getVersion()),
                serialize(pipelineResource),
                null // no properties to set
        );

        pipeline.getScripts().stream()
                .filter(script -> script.getType() == User)
                .findFirst()
                .ifPresent(publishedScript -> archiveService.writeResource(
                        toScriptPath(User, published.getPipelineCode(), published.getVersion()),
                        publishedScript.getBody().getBytes(UTF_8),
                        null // no properties to set
                ));

        return published;
    }

    /**
     * Finds the script for the specified type, pipeline and version
     *
     * @param type         The script type
     * @param pipelineCode The pipeline identifier
     * @param version      The script version (this can be the pipeline version in the case of the user script)
     * @return The published script for the given type, pipeline and version
     */
    private String findScriptBody(
            final String pipelineCode,
            final String pipelineVersion,
            final ScriptType type,
            final String version) {

        final String scriptPath = toScriptPath(type, pipelineCode, version);
        if (archiveService.exists(scriptPath)) {
            return readResourceAsString(scriptPath);
        }
        final String pipelinePath = toPipelinePath(pipelineCode, pipelineVersion);
        throw new IllegalStateException(String.format(
                "\"%s\" references \"%s\" but it could not be found. Please add the missing script or remove the script version entry from \"%s\"",
                pipelinePath,
                scriptPath,
                pipelinePath
        ));
    }

    /**
     * Finds the version of a specific script in the published pipeline scripts
     *
     * @param scripts The published pipeline scripts
     * @param type    The script type
     * @return The version of the specified script or null if the script is absent
     */
    private String findScriptVersion(final List<PublishedScript> scripts, final ScriptType type) {
        return scripts.stream()
                .filter(script -> script.getType() == type)
                .findFirst()
                .map(PublishedScript::getVersion)
                .orElse(null);
    }

    /**
     * Serializes the provided value or throws a runtime exception if it fails
     *
     * @param value The object to serialize
     * @return The serialized object
     * @throws RuntimeException if the serialization fails
     */
    private byte[] serialize(final Object value) {
        try {
            return objectMapper.writeValueAsBytes(value);
        } catch (final JsonProcessingException exception) {
            throw new RuntimeException(exception);
        }
    }

    /**
     * Serializes the provided value or throws a runtime exception if it fails
     *
     * @param value The object to deserialize
     * @param type  The object type to deserialize to
     * @return The deserialized object
     * @throws RuntimeException if the deserialization fails
     */
    private <T> T deserialize(final byte[] value, final Class<T> type) {
        try {
            return objectMapper.readValue(value, type);
        } catch (final IOException exception) {
            throw new RuntimeException(exception);
        }
    }

    private String readResourceAsString(final String location) {
        return new String(archiveService.readResource(location), UTF_8);
    }

}