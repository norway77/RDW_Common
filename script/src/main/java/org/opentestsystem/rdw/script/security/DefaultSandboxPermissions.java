package org.opentestsystem.rdw.script.security;

import java.io.FilePermission;
import java.lang.reflect.ReflectPermission;
import java.security.AccessControlException;
import java.security.Permission;
import java.security.PermissionCollection;
import java.security.Permissions;
import java.security.SecurityPermission;
import java.util.PropertyPermission;
import java.util.logging.LoggingPermission;

/**
 *  Implementation of SandboxPermissions for running user pipeline scripts. The necessary permissions
 *  are hardcoded in, but this could be changed to load from configuration.
 */
public class DefaultSandboxPermissions implements SandboxPermissions {

    // Whitelist defines permissions that will be allowed to the scripts.
    private final PermissionCollection whitelist;

    // Blacklist defines permission that will be denied to the scripts. If a permission matches
    // a rules on both the whitelist and blacklist, it will be denied.
    private final PermissionCollection blacklist;

    public DefaultSandboxPermissions() {

        // Define whitelist. Note: add new AllPermission() to make everything permitted except what
        // is on the blacklist.
        this.whitelist = new Permissions();

        // Minimal permissions needed to run Groovy scripts.
        whitelist.add(new PropertyPermission("line.separator", "read"));
        whitelist.add(new PropertyPermission("file.separator", "read"));
        whitelist.add(new PropertyPermission("path.separator", "read"));
        whitelist.add(new PropertyPermission("java.class.version", "read"));
        whitelist.add(new PropertyPermission("java.home", "read"));
        whitelist.add(new PropertyPermission("file.encoding", "read"));
        whitelist.add(new PropertyPermission("com.sun.security.*", "read"));
        whitelist.add(new PropertyPermission("sun.util.logging.*", "read"));
        whitelist.add(new LoggingPermission("control", null));
        whitelist.add(new ReflectPermission("suppressAccessChecks"));
        whitelist.add(new RuntimePermission("accessClassInPackage.sun.reflect"));
        whitelist.add(new RuntimePermission("accessDeclaredMembers"));
        whitelist.add(new RuntimePermission("createClassLoader"));
        whitelist.add(new RuntimePermission("getProtectionDomain"));
        whitelist.add(new SecurityPermission("getProperty.*"));
        whitelist.add(new FilePermission(System.getProperty("java.home") + "/lib/-", "read"));

        whitelist.add(new FilePermission("<<ALL FILES>>", "read"));

//        // These are probably only used by JUnit tests in dev to load certain classes from incremental builds.
//        // However, they should be safe to include everywhere.
//        whitelist.add(new FilePermission(System.getProperty("user.home") + "/.gradle/caches/-", "read"));
//        whitelist.add(new FilePermission(System.getProperty("user.home") + "/.m2/repository/-", "read"));
//
//        // MAC OSX folders for temp files. Some classes are read from here
//        whitelist.add(new FilePermission("/var/folders/-", "read"));
//        whitelist.add(new FilePermission("/private/var/folders/-", "read"));

        // Define blacklist. Note: leave this empty to allow everything permitted by the whitelist.
        this.blacklist = new Permissions();
    }

    @Override
    public void checkPermission(final Permission permission) throws AccessControlException {
        if (!whitelist.implies(permission)) {
            throw new AccessControlException("access denied (not whitelisted) " + permission, permission);
        }

        if (blacklist.implies(permission)) {
            throw new AccessControlException("access denied (blacklisted) " + permission, permission);
        }
    }
}
