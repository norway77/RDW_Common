package org.opentestsystem.rdw.archive;

import com.amazonaws.services.s3.AmazonS3;
import com.amazonaws.services.s3.model.ObjectMetadata;
import org.junit.Before;
import org.junit.Test;
import org.mockito.ArgumentCaptor;

import static java.nio.charset.StandardCharsets.UTF_8;
import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.eq;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

public class S3ArchiveServiceTest {

    private S3ArchiveService archiveService;
    private AmazonS3 amazonS3;
    private final String s3Root = "s3://";
    private final String tenantPath ="";
    private final String nvTenantPath ="NV";
    private final String bucket = "bucket";
    private final String sse = "AES256";
    private final String archiveRoot = s3Root + bucket;
    private final String expectedS3Root = s3Root + bucket + "/" + tenantPath ;

    @Before
    public void createArchiveService() {
        amazonS3 = mock(AmazonS3.class);
        when(amazonS3.doesBucketExist(bucket)).thenReturn(true);

        archiveService = new S3ArchiveService(amazonS3, archiveRoot, tenantPath, sse);
    }

    @Test(expected = IllegalArgumentException.class)
    public void itRequiresAS3Scheme() {
        new S3ArchiveService(amazonS3, "/tmp",  tenantPath, null);
    }

    @Test(expected = IllegalArgumentException.class)
    public void itRequiresAnExistingBucket() {
        when(amazonS3.doesBucketExist(bucket)).thenReturn(false);
        new S3ArchiveService(amazonS3, archiveRoot, tenantPath, null);
    }

    @Test
    public void itShouldUseClientForExists() {
        final String location = "TEST/f1/f2/test";
        when(amazonS3.doesObjectExist(bucket, location)).thenReturn(false).thenReturn(true);
        assertThat(archiveService.exists(location)).isFalse();
        assertThat(archiveService.exists(location)).isTrue();
    }

    @Test
    public void itShouldUseClientForWrite() {
        final String location = "TEST/f1/f2/test";
        final byte[] content = "payload".getBytes(UTF_8);
        archiveService.writeResource(location, content, null);

        final ArgumentCaptor<ObjectMetadata> captor = ArgumentCaptor.forClass(ObjectMetadata.class);
        verify(amazonS3).putObject(eq(bucket), eq(location), any(), captor.capture());
        assertThat(captor.getValue().getSSEAlgorithm()).isEqualTo(sse);
    }

    @Test
    public void itShouldReturnRawUriForALocation() {
        String location = "exams/report/file.pdf";
        S3ArchiveService s3ArchiveService = new S3ArchiveService(amazonS3, archiveRoot, tenantPath, sse);

        String actual = s3ArchiveService.getRawUri(location);
        assertThat(actual).isEqualTo(expectedS3Root + location);
    }

    @Test
    public void itShouldReturnRawUriForALocationWithATenant() {
        String location = "exams/report/file.pdf";
        S3ArchiveService s3ArchiveService = new S3ArchiveService(amazonS3, archiveRoot, nvTenantPath, sse);

        String actual = s3ArchiveService.getRawUri(location);
        assertThat(actual).isEqualTo(archiveRoot + "/" + nvTenantPath + "/" + location);
    }

    @Test
    public void itShouldReturnRawUriForALocationRootHasTrailingSlash() {
        String location = "exams/report/file.pdf";
        S3ArchiveService s3ArchiveService = new S3ArchiveService(amazonS3, archiveRoot, tenantPath, sse);

        String actual = s3ArchiveService.getRawUri(location);
        assertThat(actual).isEqualTo(expectedS3Root + location);
    }

    @Test
    public void itShouldReturnRawUriForALocationRootHasTrailingSlashWithTenant() {
        String location = "exams/report/file.pdf";
        S3ArchiveService s3ArchiveService = new S3ArchiveService(amazonS3, archiveRoot, nvTenantPath, sse);

        String actual = s3ArchiveService.getRawUri(location);
        assertThat(actual).isEqualTo(expectedS3Root + nvTenantPath + "/" + location);
    }

}
