package org.opentestsystem.rdw.archive;

import com.amazonaws.services.s3.AmazonS3;
import com.amazonaws.services.s3.model.ObjectMetadata;
import org.junit.Before;
import org.junit.Test;
import org.mockito.ArgumentCaptor;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import static java.nio.charset.StandardCharsets.UTF_8;
import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.eq;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

/**
 * New layout for s3 archive service to support tenant
 *
 * archive:
 *   aws:                      // required for s3 connection
 *     access-key: bar
 *     secret-key: baz
 *     region: foo1
 *     sse: bar2
 *     bucket: s3://mybucket  // - the default s3 root and bucket
 *     object-prefix:         // - the default tentant path
 *   tenants:
 *     ca:
 *       aws:
 *         bucket: s3://new bucket
 *         object-prefix: tenant_ca
 */
public class S3ArchiveServiceTest {
    private static final Logger logger = LoggerFactory.getLogger(S3ArchiveServiceTest.class);

    private S3ArchiveService archiveService;
    ArchiveAwsProperties archiveAwsProperties;

    private AmazonS3 amazonS3;
    private final String accessKeyTest = "accessKeyTest";
    private final String secretKey = "secretKey";
    private final String region = "us-west-2";
    private final String objectPrefix ="";
    private final String nvObjectPrefix ="NV";
    private final String bucket = "bucket";
    private final String s3Bucket = "s3://" + bucket;
    private final String sse = "AES256";

    @Before
    public void createArchiveService() {
        archiveAwsProperties = getArchiveAwsProperties();
        amazonS3 = mock(AmazonS3.class);
        when(amazonS3.doesBucketExist(bucket)).thenReturn(true);

        archiveService = new S3ArchiveService(amazonS3, archiveAwsProperties);
    }

    // creates with default null tenant.
    private ArchiveAwsProperties getArchiveAwsProperties() {
        ArchiveAwsProperties archiveAwsProperties = new ArchiveAwsProperties();
        archiveAwsProperties.setAccessKey(accessKeyTest);
        archiveAwsProperties.setBucket(s3Bucket);
        archiveAwsProperties.setObjectPrefix(objectPrefix);
        archiveAwsProperties.setRegion(region);
        archiveAwsProperties.setSecretKey(secretKey);
        archiveAwsProperties.setSse(sse);
        return archiveAwsProperties;
    }


    @Test(expected = IllegalArgumentException.class)
    public void itRequiresAS3Scheme() {
        archiveAwsProperties.setBucket("/tmp");
        new S3ArchiveService(amazonS3, archiveAwsProperties);
    }

    @Test(expected = IllegalArgumentException.class)
    public void itRequiresAnExistingBucket() {
        // test is using just the bucket name
        logger.info("arcProps-bucket" + archiveAwsProperties.getBucket());
        when(amazonS3.doesBucketExist(bucket)).thenReturn(false);
        new S3ArchiveService(amazonS3, archiveAwsProperties);
    }

    @Test
    public void itShouldUseClientForExists() {
        final String location = "TEST/f1/f2/test";
        when(amazonS3.doesObjectExist(bucket, location)).thenReturn(false).thenReturn(true);
        assertThat(archiveService.exists(location)).isFalse();
        assertThat(archiveService.exists(location)).isTrue();
    }

    @Test
    public void itShouldUseClientForWrite() {
        final String location = "TEST/f1/f2/test";
        final byte[] content = "payload".getBytes(UTF_8);
        archiveService.writeResource(location, content, null);

        final ArgumentCaptor<ObjectMetadata> captor = ArgumentCaptor.forClass(ObjectMetadata.class);
        verify(amazonS3).putObject(eq(bucket), eq(location), any(), captor.capture());
        assertThat(captor.getValue().getSSEAlgorithm()).isEqualTo(sse);
    }

    @Test
    public void itShouldReturnRawUriForALocation() {
        String location = "exams/report/file.pdf";
        archiveAwsProperties.setBucket(s3Bucket + objectPrefix);
        S3ArchiveService s3ArchiveService = new S3ArchiveService(amazonS3, archiveAwsProperties);

        String actual = s3ArchiveService.getRawUri(location);
        assertThat(actual).isEqualTo(archiveAwsProperties.getBucket() + "/" + location);
    }

    @Test
    public void itShouldReturnRawUriForALocationWithATenant() {
        String location = "exams/report/file.pdf";
        archiveAwsProperties.setBucket(s3Bucket +  "/" + nvObjectPrefix);
        archiveAwsProperties.setObjectPrefix(nvObjectPrefix);
        when(amazonS3.doesBucketExist(bucket+  "/" + nvObjectPrefix)).thenReturn(true);

        S3ArchiveService s3ArchiveService = new S3ArchiveService(amazonS3, archiveAwsProperties);

        String actual = s3ArchiveService.getRawUri(location);
        assertThat(actual).isEqualTo(archiveAwsProperties.getBucket() + "/" + location);
    }

    @Test
    public void itShouldReturnRawUriForALocationRootHasTrailingSlash() {
        String location = "exams/report/file.pdf";
        archiveAwsProperties.setBucket(s3Bucket + "/");
        S3ArchiveService s3ArchiveService = new S3ArchiveService(amazonS3, archiveAwsProperties);

        String actual = s3ArchiveService.getRawUri(location);
        assertThat(actual).isEqualTo(archiveAwsProperties.getBucket() + "/" + location);
    }

    @Test
    public void itShouldReturnRawUriForALocationRootHasTrailingSlashWithTenant() {
        String location = "exams/report/file.pdf";
        archiveAwsProperties.setBucket(s3Bucket +  "/" + nvObjectPrefix);
        archiveAwsProperties.setObjectPrefix(nvObjectPrefix);
        when(amazonS3.doesBucketExist(bucket+  "/" + nvObjectPrefix)).thenReturn(true);

        S3ArchiveService s3ArchiveService = new S3ArchiveService(amazonS3, archiveAwsProperties);

        String actual = s3ArchiveService.getRawUri(location);
        assertThat(actual).isEqualTo(archiveAwsProperties.getBucket() + "/" + location);
    }

}
