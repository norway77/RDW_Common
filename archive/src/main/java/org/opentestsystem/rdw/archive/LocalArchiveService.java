package org.opentestsystem.rdw.archive;

import com.amazonaws.services.s3.Headers;
import com.google.common.collect.ImmutableMap;
import com.google.common.io.Files;
import com.google.common.io.MoreFiles;
import com.google.common.io.RecursiveDeleteOption;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.util.StreamUtils;

import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.ByteArrayInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.Reader;
import java.io.Writer;
import java.net.URLConnection;
import java.util.Map;
import java.util.Properties;

/**
 * An {@link ArchiveService} implementation that uses the local file system.
 *
 * @see ArchiveConfiguration
 */
public class LocalArchiveService implements ArchiveService {
    private static final Logger logger = LoggerFactory.getLogger(LocalArchiveService.class);
    private static final String FileSchemePrefix = "file://";

    private final String rootPath;

    private static final Map<String, String> ExtensionToMediaType = ImmutableMap.<String, String>builder()
            .put("csv", "text/csv")
            .build();

    /**
     * @param archiveProperties uriRoot, must start with "file://", e.g. "file:///tmp/"
     */
    public LocalArchiveService(final ArchiveProperties archiveProperties) {
        if (!archiveProperties.isConfiguredFile()) {
            throw new IllegalArgumentException("Invalid local file root " + archiveProperties.getUriRoot());
        }
        final String path = archiveProperties.getUriRoot().substring(FileSchemePrefix.length());
        final String cleanPath = appendSeparatorIfMissing(path);
        if (archiveProperties.getPathPrefix() == null || archiveProperties.getPathPrefix().equals("")) {
            rootPath = cleanPath;
        } else {
            rootPath = cleanPath + appendSeparatorIfMissing(archiveProperties.getPathPrefix());
        }
    }

    private String appendSeparatorIfMissing(String path) {
        return path.endsWith(File.separator) ? path : (path + File.separator);
    }

    @Override
    public String getRawUri(final String location) {
        return FileSchemePrefix + realResourceFile(location).getAbsolutePath();
    }

    @Override
    public void writeResource(final String location, final byte[] content, final Properties properties) {
        writeResource(location, new ByteArrayInputStream(content), properties);
    }

    @Override
    public void writeResource(final String location, final InputStream is, final Properties properties) {
        final File file = realResourceFile(location);

        final File folder = file.getParentFile();
        if (!folder.exists()) {
            if (!folder.mkdirs()) {
                throw new IllegalArgumentException("Error creating local path " + folder.getPath());
            }
        }

        try (final OutputStream os = new BufferedOutputStream(new FileOutputStream(file, false))) {
            StreamUtils.copy(is, os);
        } catch (final IOException e) {
            final String msg = "Error writing content to " + file.getPath();
            logger.warn(msg, e);
            throw new RuntimeException(msg, e);
        }

        if (properties != null && !properties.isEmpty()) {
            writePropertiesToFile(location, properties);
        }
    }

    @Override
    public byte[] readResource(final String location) {
        try (final InputStream is = openResource(location)) {
            return StreamUtils.copyToByteArray(new BufferedInputStream(is));
        } catch (final IOException e) {
            final String msg = "Error reading content from " + realResourceFile(location).getPath();
            logger.warn(msg, e);
            throw new RuntimeException(msg, e);
        }
    }

    @Override
    public InputStream openResource(final String location) {
        final File file = realResourceFile(location);
        if (!file.isFile()) {
            throw new IllegalArgumentException("Invalid resource location " + location);
        }
        try {
            return new FileInputStream(file);
        } catch (final IOException e) {
            final String msg = "Error opening content from " + file.getPath();
            logger.warn(msg, e);
            throw new RuntimeException(msg, e);
        }
    }

    @Override
    public Properties readProperties(final String location) {
        final Properties properties = readPropertiesFromFile(location);

        // add the content length and raw URI
        final File resourceFile = realResourceFile(location);
        properties.put(Headers.CONTENT_LENGTH, resourceFile.length());
        properties.put(ArchiveService.RawURI, FileSchemePrefix + resourceFile.getAbsolutePath());

        // If the content type is not set, guess it from the file name.
        if (!properties.containsKey(Headers.CONTENT_TYPE)) {
            String contentType = guessContentType(resourceFile.getName());
            if (contentType != null) {
                properties.put(Headers.CONTENT_TYPE, contentType);
            }
        }

        return properties;
    }

    @Override
    public void writeProperties(final String location, final Properties properties) {
        final Properties fileProperties = readPropertiesFromFile(location);

        for (final Map.Entry<Object, Object> entry : normalizeProperties(properties).entrySet()) {
            fileProperties.setProperty((String) entry.getKey(), (String) entry.getValue());
        }

        writePropertiesToFile(location, fileProperties);
    }

    @Override
    public void delete(final String location) {
        final File file = realResourceFile(location);
        if (file.isFile()) {
            final File properties = realPropertiesFile(location);
            if (properties.isFile()) {
                if (!properties.delete()) {
                    logger.warn("Failed to delete " + properties.getPath());
                }
            }
            if (!file.delete()) {
                logger.warn("Failed to delete " + file.getPath());
            }
        } else if (file.isDirectory()) {
            try {
                MoreFiles.deleteRecursively(file.toPath(), RecursiveDeleteOption.ALLOW_INSECURE);
            } catch (IOException e) {
                logger.warn("Error deleting " + file.getPath(), e);
                throw new RuntimeException(e);
            }
        } else {
            throw new IllegalArgumentException("Invalid location " + location);
        }
    }

    @Override
    public boolean exists(final String location) {
        return realResourceFile(location).isFile();
    }

    private void writePropertiesToFile(final String location, final Properties properties) {
        try (final Writer writer = new BufferedWriter(new FileWriter(realPropertiesFile(location), false))) {
            normalizeProperties(properties).store(writer, null);
        } catch (final IOException e) {
            final String msg = "Error writing properties to " + realPropertiesFile(location).getPath();
            logger.warn(msg, e);
            throw new RuntimeException(msg, e);
        }
    }

    private Properties readPropertiesFromFile(final String location) {
        if (!exists(location)) {
            throw new IllegalArgumentException("Invalid resource location " + location);
        }

        final Properties properties = new Properties();
        final File propertiesFile = realPropertiesFile(location);

        if (propertiesFile.isFile()) {
            try (final Reader reader = new BufferedReader(new FileReader(propertiesFile))) {
                properties.load(reader);
            } catch (final IOException e) {
                final String msg = "Error reading properties from " + propertiesFile.getPath();
                logger.warn(msg, e);
                throw new RuntimeException(msg, e);
            }
        }

        // cleanup legacy properties
        normalizeProperties(properties);
        return properties;
    }

    private File realResourceFile(final String location) {
        try {
            return new File(rootPath + location).getCanonicalFile();
        } catch (IOException e) {
            throw new IllegalArgumentException("Error with local file location " + location);
        }
    }

    private File realPropertiesFile(final String location) {
        try {
            return new File(rootPath + location + ".properties").getCanonicalFile();
        } catch (IOException e) {
            throw new IllegalArgumentException("Error with local file location " + location);
        }
    }

    static boolean validRoot(final String root) {
        return root != null && root.toLowerCase().startsWith(FileSchemePrefix);
    }

    private static Properties normalizeProperties(final Properties properties) {
        if (properties == null || properties.isEmpty()) return properties;

        // there may be legacy code / storage that uses "content-type" instead of "Content-Type"
        final String LegacyContentType = "content-type";
        if (properties.containsKey(LegacyContentType)) {
            if (!properties.containsKey(Headers.CONTENT_TYPE)) {
                properties.put(Headers.CONTENT_TYPE, properties.get(LegacyContentType));
            }
            properties.remove(LegacyContentType);
        }

        // remove non-string properties because local write just can't deal with that
        properties.entrySet().removeIf(entry -> !String.class.isInstance(entry.getValue()));

        return properties;
    }

    static String guessContentType(final String filename) {
        final String contentTypeFromName = URLConnection.guessContentTypeFromName(filename);
        if (contentTypeFromName != null) {
            return contentTypeFromName;
        }

        return ExtensionToMediaType.get(Files.getFileExtension(filename).toLowerCase());
    }
}
